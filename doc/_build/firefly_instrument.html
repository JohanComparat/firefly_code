<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>firefly instrument &#8212; FIREFLY - Fitting Iteratively for Relative Likelihood Analysis 1.0.4 documentation</title>
    
    <link rel="stylesheet" href="_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.0.4',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="firefly library" href="firefly_library.html" />
    <link rel="prev" title="firefly dust" href="firefly_dust.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="firefly_library.html" title="firefly library"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="firefly_dust.html" title="firefly dust"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">FIREFLY - Fitting Iteratively for Relative Likelihood Analysis 1.0.4 documentation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="firefly-instrument">
<h1>firefly instrument<a class="headerlink" href="#firefly-instrument" title="Permalink to this headline">¶</a></h1>
<p>This class handles instrumental properties that influence the FIREFLY fitting process.</p>
<span class="target" id="module-firefly_instrument"></span><p>Provides a set of functions to handle instrumental effects.</p>
<p><code class="xref py py-func docutils literal"><span class="pre">log_rebin()</span></code> has been pulled from
<code class="xref py py-mod docutils literal"><span class="pre">mangadap.contrib.ppxf_util.py</span></code> and modified.</p>
<dl class="docutils">
<dt><em>Source location</em>:</dt>
<dd>$MANGADAP_DIR/python/mangadap/util/instrument.py</dd>
</dl>
<p><em>Python2/3 compliance</em>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">absolute_import</span>

<span class="kn">import</span> <span class="nn">sys</span>
<span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version</span> <span class="o">&gt;</span> <span class="s1">&#39;3&#39;</span><span class="p">:</span>
    <span class="n">long</span> <span class="o">=</span> <span class="nb">int</span>
</pre></div>
</div>
<p><em>Imports</em>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="k">import</span> <span class="n">InterpolatedUnivariateSpline</span>
<span class="kn">import</span> <span class="nn">astropy.constants</span>
</pre></div>
</div>
<dl class="docutils">
<dt><em>Revision history</em>:</dt>
<dd><div class="first last line-block">
<div class="line"><a href="#id1"><span class="problematic" id="id2">**</span></a>24 May 2017 - Implemented the new downgrader version (D. Goddard)</div>
</div>
</dd>
</dl>
<dl class="class">
<dt id="firefly_instrument.VariableGaussianKernel">
<em class="property">class </em><code class="descclassname">firefly_instrument.</code><code class="descname">VariableGaussianKernel</code><span class="sig-paren">(</span><em>sigma</em>, <em>minsig=0.01</em>, <em>nsig=3.0</em>, <em>integral=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/firefly_instrument.html#VariableGaussianKernel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#firefly_instrument.VariableGaussianKernel" title="Permalink to this definition">¶</a></dt>
<dd><p>Support class for variable sigma convolution.  See
<a class="reference internal" href="#firefly_instrument.convolution_variable_sigma" title="firefly_instrument.convolution_variable_sigma"><code class="xref py py-func docutils literal"><span class="pre">convolution_variable_sigma()</span></code></a>.</p>
<p>Stolen from M. Cappellari&#8217;s gaussian_filter1d function.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><p class="first">y (np.ndarray): Vector to convolve
sigma (np.ndarray): Coordinate-dependent standard deviation of the</p>
<blockquote>
<div>Gaussian kernel</div></blockquote>
<dl class="last docutils">
<dt>ye (np.ndarray): (<strong>Optional</strong>) Error in the vector to</dt>
<dd>convolve</dd>
</dl>
</dd>
<dt>Raises:</dt>
<dd><dl class="first last docutils">
<dt>ValueError: Raised if <em>y</em> is not a 1D vector, or if the shape of</dt>
<dd><em>y</em> and <em>sigma</em> (and <em>ye</em> if provided) are different.</dd>
</dl>
</dd>
<dt>Attributes:</dt>
<dd><p class="first">x (np.ndarray): Pixel coordinate vector
y (np.ndarray): Vector to convolve
ye (np.ndarray): Error in the vector to convolve
sigma (np.ndarray): Coordinate-dependent standard deviation of the</p>
<blockquote>
<div>Gaussian kernel</div></blockquote>
<dl class="last docutils">
<dt>norm (np.ndarray): Gaussian normalization; calculated once for</dt>
<dd>efficiency</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="firefly_instrument.convolution_integral_element">
<em class="property">class </em><code class="descclassname">firefly_instrument.</code><code class="descname">convolution_integral_element</code><span class="sig-paren">(</span><em>y</em>, <em>sigma</em>, <em>ye=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/firefly_instrument.html#convolution_integral_element"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#firefly_instrument.convolution_integral_element" title="Permalink to this definition">¶</a></dt>
<dd><p>Support class for variable sigma convolution.  See
<a class="reference internal" href="#firefly_instrument.convolution_variable_sigma" title="firefly_instrument.convolution_variable_sigma"><code class="xref py py-func docutils literal"><span class="pre">convolution_variable_sigma()</span></code></a>.</p>
<p>OUT OF DATE; DO NOT USE</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><p class="first">y (np.ndarray): Vector to convolve
sigma (np.ndarray): Coordinate-dependent standard deviation of the</p>
<blockquote>
<div>Gaussian kernel</div></blockquote>
<dl class="last docutils">
<dt>ye (np.ndarray): (<strong>Optional</strong>) Error in the vector to</dt>
<dd>convolve</dd>
</dl>
</dd>
<dt>Raises:</dt>
<dd><dl class="first last docutils">
<dt>ValueError: Raised if <em>y</em> is not a 1D vector, or if the shape of</dt>
<dd><em>y</em> and <em>sigma</em> (and <em>ye</em> if provided) are different.</dd>
</dl>
</dd>
<dt>Attributes:</dt>
<dd><p class="first">x (np.ndarray): Pixel coordinate vector
y (np.ndarray): Vector to convolve
ye (np.ndarray): Error in the vector to convolve
sigma (np.ndarray): Coordinate-dependent standard deviation of the</p>
<blockquote>
<div>Gaussian kernel</div></blockquote>
<dl class="last docutils">
<dt>norm (np.ndarray): Gaussian normalization; calculated once for</dt>
<dd>efficiency</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="firefly_instrument.convolution_integral_element.error">
<code class="descname">error</code><span class="sig-paren">(</span><em>xc</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/firefly_instrument.html#convolution_integral_element.error"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#firefly_instrument.convolution_integral_element.error" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the error in the weighted mean of <code class="xref py py-attr docutils literal"><span class="pre">y</span></code> using
nominal error propagation.  The weights are defined by a
Gaussian with standard deviation <code class="xref py py-attr docutils literal"><span class="pre">sigma</span></code> and centered at
xc.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>xc (float): Center for the Gaussian weighting function</dd>
<dt>Returns:</dt>
<dd>float: The error in the weighted mean of <code class="xref py py-attr docutils literal"><span class="pre">y</span></code></dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="firefly_instrument.convolution_variable_sigma">
<code class="descclassname">firefly_instrument.</code><code class="descname">convolution_variable_sigma</code><span class="sig-paren">(</span><em>y</em>, <em>sigma</em>, <em>ye=None</em>, <em>integral=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/firefly_instrument.html#convolution_variable_sigma"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#firefly_instrument.convolution_variable_sigma" title="Permalink to this definition">¶</a></dt>
<dd><p>Convolve a discretely sampled function <span class="math">\(y(x)\)</span> with a Gaussian
kernel, <span class="math">\(g\)</span>, where the standard deviation of the kernel is a
function of <span class="math">\(x\)</span>, <span class="math">\(\sigma(x)\)</span>.  Nominal calculations can
be performed to propagate the error in the result; these
calculations <strong>do not</strong> include the covariance between the pixels,
which will mean that the calculations likely have significant error!</p>
<p>The convolution is defined as:</p>
<div class="math">
\[\begin{split}(y\ast g)(x) &amp;= \int_{-\infty}^{\infty} y(X)\ g(\sigma,x-X)\ dX \\
             &amp;= \int_{-\infty}^{\infty} \frac{y(X)}{\sqrt{2\pi}\
                \sigma(X)}\ \exp\left(-\frac{(x-X)^2}{2\
                \sigma(X)^2}\right) dX .\end{split}\]</div>
<p>To minimize edge effects and account for the censoring of the data
(finite range in <span class="math">\(x\)</span>), the convolution is actually calculated
as a definite integral and normalized as follows:</p>
<div class="math">
\[(y\ast g)(x) \sim\frac{
\int_{x-n_\sigma*\sigma(x)}^{x+n_\sigma*\sigma(x)} y(X)\
g(\sigma,x-X)\ dX}{
\int_{x-n_\sigma*\sigma(x)}^{x+n_\sigma*\sigma(x)}
g(\sigma,x-X)\ dX} .\]</div>
<p>The above is identical to getting the weighted mean of <span class="math">\(y\)</span> at
each position <span class="math">\(x\)</span>, where the weights are defined by a Gaussian
kernel centered at <span class="math">\(x\)</span> with a variable dispersion.</p>
<dl class="docutils">
<dt>Use of this function requires:</dt>
<dd><ul class="first last simple">
<li><em>y</em> and <em>sigma</em> must be 1D vectors</li>
<li><em>y</em> and <em>sigma</em> must be uniformly sampled on the same grid</li>
<li><em>sigma</em> must be in pixel units.</li>
</ul>
</dd>
<dt>Args:</dt>
<dd><p class="first">y (np.ndarray): A uniformly sampled function to convolve.
sigma (np.ndarray): The standard deviation of the Gaussian</p>
<blockquote>
<div>kernel sampled at the same positions as <em>y</em>.  The units of
<em>sigma</em> <strong>must</strong> be in pixels.</div></blockquote>
<dl class="last docutils">
<dt>ye (np.ndarray): (<strong>Optional</strong>) Errors in the function</dt>
<dd><span class="math">\(y(x)\)</span>.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>np.ndarray: Arrays with the convolved function <span class="math">\((y\ast
g)(x)\)</span> sampled at the same positions as the input <span class="math">\(x\)</span>
vector and its error.  The second array will be returned as None
if the error vector is not provided.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="firefly_instrument.downgrade">
<code class="descclassname">firefly_instrument.</code><code class="descname">downgrade</code><span class="sig-paren">(</span><em>wave</em>, <em>flux</em>, <em>deltal_in</em>, <em>sigma_galaxy</em>, <em>wave_instrument</em>, <em>r_instrument</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/firefly_instrument.html#downgrade"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#firefly_instrument.downgrade" title="Permalink to this definition">¶</a></dt>
<dd><p>Adapted from the manga DAP downgrader from Kyle Westfall.</p>
<p>Downgrades an input spectrum to a given galaxy velocity dispersion
using the input SEDs resolution and the resolution of the observation.</p>
<p>Returns flux of downgraded SED.</p>
</dd></dl>

<dl class="function">
<dt id="firefly_instrument.match_spectral_resolution">
<code class="descclassname">firefly_instrument.</code><code class="descname">match_spectral_resolution</code><span class="sig-paren">(</span><em>wave</em>, <em>flux</em>, <em>sres</em>, <em>new_sres_wave</em>, <em>new_sres</em>, <em>ivar=None</em>, <em>mask=None</em>, <em>min_sig_pix=0.0</em>, <em>no_offset=True</em>, <em>variable_offset=False</em>, <em>log10=False</em>, <em>new_log10=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/firefly_instrument.html#match_spectral_resolution"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#firefly_instrument.match_spectral_resolution" title="Permalink to this definition">¶</a></dt>
<dd><p>Adjust the existing spectral resolution of a spectrum to a <strong>lower</strong>
resolution as best as possible.  The primary functionality is in
<a class="reference internal" href="#firefly_instrument.spectral_resolution" title="firefly_instrument.spectral_resolution"><code class="xref py py-class docutils literal"><span class="pre">spectral_resolution</span></code></a>, which determines the Gaussian kernel
parameters needed to match the resolution, and
<code class="xref py py-func docutils literal"><span class="pre">convolve_variable_sigma()</span></code>, which actually performs the
convolution to match the resolution.</p>
<p>In particular, see
<a class="reference internal" href="#firefly_instrument.spectral_resolution.GaussianKernelDifference" title="firefly_instrument.spectral_resolution.GaussianKernelDifference"><code class="xref py py-func docutils literal"><span class="pre">spectral_resolution.GaussianKernelDifference()</span></code></a> for a
description of how the kernel parameters are determined and how
regions where the target resolution is <strong>higher</strong> than the existing
resolution.  In this case, one of the options is to adopt an offset
of the resolution (in km/s) that could be corrected for in
subsequent analysis.  In this case, setting <em>variable_offset</em> to
True allows the offset to be different for all input spectra.  If
one expects to combine the spectra, the default behavior should be
used, forcing all the spectra to have a constant offset.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>wave (np.ndarray): A 1D or 2D (:math:<a href="#id3"><span class="problematic" id="id4">`</span></a>N_{rm spec}times</dt>
<dd>N_{rm pix}`) array with the wavelength in angstroms for a
set of spectra.  The sampling may be either in linear steps
of wavelength or <span class="math">\(\log_{10}\)</span> steps, as set using
<em>log10</em>.</dd>
<dt>flux (np.ndarray): A 1D or 2D (:math:<a href="#id5"><span class="problematic" id="id6">`</span></a>N_{rm spec}times</dt>
<dd>N_{rm pix}`) array with the flux sampled at the provided
wavelengths.</dd>
<dt>sres (np.ndarray): A 1D or 2D (:math:<a href="#id7"><span class="problematic" id="id8">`</span></a>N_{rm spec}times</dt>
<dd>N_{rm pix}`) array with the spectral resolution, <span class="math">\(R\)</span>,
at the provided wavelengths.</dd>
<dt>new_sres_wave (np.ndarray): A 1D vector with the wavelength</dt>
<dd>in angstroms at which the new resolution of the input
spectra has been sampled.  The sampling may be either in
linear steps of wavelength or <span class="math">\(\log_{10}\)</span> steps, as
set using <em>new_log10</em>.</dd>
<dt>new_sres (np.ndarray): A 1D vector with the new resolution</dt>
<dd>for the input spectra.</dd>
<dt>ivar (np.ndarray): (<strong>Optional</strong>) A 1D or 2D (:math:<a href="#id9"><span class="problematic" id="id10">`</span></a>N_{rm</dt>
<dd><p class="first">spec}times N_{rm pix}`) array with the inverse variance of
the flux sampled at the provided wavelengths.  This vector
is used to estimate the noise in the resolution-matched
spectra.</p>
<div class="last admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The accuracy of the errors still remain untested!</p>
</div>
</dd>
<dt>mask (np.ndarray): (<strong>Optional</strong>) A 1D or 2D (:math:<a href="#id11"><span class="problematic" id="id12">`</span></a>N_{rm</dt>
<dd>spec}times N_{rm pix}`) array with a <em>uint</em> mask for the
flux sampled at the provided wavelengths.</dd>
<dt>no_offset (bool): (<strong>Optional</strong>) Force :math:<a href="#id13"><span class="problematic" id="id14">`</span></a>sigma^2_{v,o} =</dt>
<dd>0` by masking regions with <span class="math">\(\sigma_{p,d} &lt;
-\epsilon_\sigma\)</span>; i.e., the value of this arguments selects
Option 1 (True) or Option 2 (False).  See
<a class="reference internal" href="#firefly_instrument.spectral_resolution.GaussianKernelDifference" title="firefly_instrument.spectral_resolution.GaussianKernelDifference"><code class="xref py py-func docutils literal"><span class="pre">spectral_resolution.GaussianKernelDifference()</span></code></a>.</dd>
<dt>min_sig_pix (float): (<strong>Optional</strong>) Minimum value of the</dt>
<dd>standard deviation in pixels allowed before assuming the
kernel is a Delta function.</dd>
<dt>variable_offset (bool): (<strong>Optional</strong>) Flag to allow the offset</dt>
<dd>applied to each spectrum (when the input contains more than
one spectraum) to be tailored to each spectrum.  Otherwise
(<em>variable_offset=False</em>) the offset is forced to be the
same for all spectra.</dd>
<dt>log10 (bool): (<strong>Optional</strong>) Flag that the spectrum has been</dt>
<dd>binned logarithmically (base 10) in wavelength</dd>
<dt>new_log10 (bool): (<strong>Optional</strong>) Flag that the coordinates of</dt>
<dd>the new spectral resolution are  spectrum as been binned
logarithmically (base 10) in wavelength.</dd>
</dl>
</dd>
<dt>Returns: </dt>
<dd><p class="first">np.ndarray: Five objects are returned:</p>
<blockquote class="last">
<div><ul class="simple">
<li>A 1D or 2D (<span class="math">\(N_{\rm spec}\times N_{\rm pix}\)</span>) array
with the resolution-matched flux sampled at the input
wavelengths.</li>
<li>A 1D or 2D (<span class="math">\(N_{\rm spec}\times N_{\rm pix}\)</span>) array
with the spectral resolution, <span class="math">\(R\)</span>, of the
resolution-matched spectra at the provided wavelengths.</li>
<li>A 1D vector with any constant offset in resolution <strong>in
km/s</strong> between the targetted value and the result.  See
<a class="reference internal" href="#firefly_instrument.spectral_resolution.GaussianKernelDifference" title="firefly_instrument.spectral_resolution.GaussianKernelDifference"><code class="xref py py-func docutils literal"><span class="pre">spectral_resolution.GaussianKernelDifference()</span></code></a>.</li>
<li>A 1D or 2D (<span class="math">\(N_{\rm spec}\times N_{\rm pix}\)</span>) array
with a <em>uint</em> mask for the resolution-matched flux sampled
at the input wavelengths.  This is returned regardless of
whether an input mask was provided.  Any pixel that had a
resolution that was lower than the target resolution (up
to some tolerance defined by <em>min_sig_pix</em>) is returned as
masked.</li>
<li>A 1D or 2D (<span class="math">\(N_{\rm spec}\times N_{\rm pix}\)</span>) array
with the inverse variance of the resolution-matched flux
sampled at the input wavelengths.  If <em>ivar</em>
is not provided, a &#8216;None&#8217; returned as the last element</li>
</ul>
</div></blockquote>
</dd>
<dt>Raises:</dt>
<dd><p class="first">ValueError: Raised if:</p>
<blockquote class="last">
<div><ul class="simple">
<li>the input <em>wave</em> array is 2D and the <em>sres</em> array is not;
a 1D wavelength array is allowed for a 2D <em>sres</em> array but
not vice versa</li>
<li>the number of spectral pixels in <em>wave</em>, <em>flux</em>, and
<em>sres</em> is not the same</li>
<li>the shape of the <em>flux</em>, <em>mask</em> (if provided), and <em>ivar</em>
(if provided) are not the same</li>
<li>the shape of the <em>new_sres_wave</em> and <em>new_sres</em> arrays
are not the same and/or not 1D</li>
</ul>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="firefly_instrument.resample_vector">
<code class="descclassname">firefly_instrument.</code><code class="descname">resample_vector</code><span class="sig-paren">(</span><em>y</em>, <em>xRange=None</em>, <em>inLog=False</em>, <em>newRange=None</em>, <em>newpix=None</em>, <em>newLog=True</em>, <em>dx=None</em>, <em>base=10.0</em>, <em>ext_value=0.0</em>, <em>conserve=False</em>, <em>flat=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/firefly_instrument.html#resample_vector"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#firefly_instrument.resample_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Resample the provided vector to a new grid using integration.</p>
<p>This is a generalization of the routine <code class="xref py py-func docutils literal"><span class="pre">log_rebin()</span></code> provided
by Michele Cappellari in the pPXF package.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><p class="first">y (np.ndarray): Vector to resample.  Must be 1-D.
xRange (array): (<strong>Optional</strong>) A two-element array with the</p>
<blockquote>
<div>starting and ending value for the coordinates of the centers
of the first and last pixels in y.  If not provided, the
pixel coordinates are used; i.e., xRange = [0,y.size-1].</div></blockquote>
<dl class="last docutils">
<dt>inLog (bool): (<strong>Optional</strong>) Flag that the input vector is</dt>
<dd>logarithmically spaced within xRange.  Cannot be used if
xRange is not provided!</dd>
<dt>newRange (array): (<strong>Optional</strong>) Coordinates for the centers of</dt>
<dd>the first and last pixel in the output vector.  If not
provided, assumed to be the same as the input range.</dd>
<dt>newpix (int): (<strong>Optional</strong>) Number of pixels for the output</dt>
<dd>vector.  If not provided, assumed to be the same as the
input vector.</dd>
<dt>newLog (bool): (<strong>Optional</strong>) The output vector should be</dt>
<dd>logarithmically binned in the x-coordinates.</dd>
<dt>dx (float): (<strong>Optional</strong>) The sampling step for the output</dt>
<dd>vector.  If <em>newLog</em> is True, this has to be the change in
the logarithm of x for the output vector!  If not provided,
the sampling is set by the output range (see <em>newRange</em>
above) and number of pixels (see <em>newpix</em> above).</dd>
<dt>base (float): (<strong>Optional</strong>) When logarithmically binning the</dt>
<dd>output vector, use this as the base.  The default is 10.0;
use np.exp(1) for natural logarithm.</dd>
<dt>ext_value (float): (<strong>Optional</strong>) Set extrapolated values to the</dt>
<dd>provided float.</dd>
<dt>conserve (bool): (<strong>Optional</strong>) Conserve the integral of the</dt>
<dd>input vector.  For example, if the input vector is a
spectrum in flux units, you should conserve the flux in the
resampling; if the spectrum is in units of flux density, you
do not want to conserve the integral.</dd>
<dt>flat (bool): (<strong>Optional</strong>) Assume the &#8216;true&#8217; y function is flat</dt>
<dd>across a pixel, as is done in M. Cappellari&#8217;s log_rebin
routine; this is the default behavior.  If set to False, the
integration follows a basic linear interpolation across the
pixel.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>np.ndarray: Two numpy arrays with the new x coordinates and
new y values for the resampled vector.</dd>
<dt>Raises:</dt>
<dd><dl class="first last docutils">
<dt>ValueError: Raised if <em>y</em> is not of type np.ndarray, if <em>y</em></dt>
<dd>is not one-dimensional, or if <em>xRange</em> is not provided and
the input vector is logarithmically binned (see <em>inLog</em>
above).</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="firefly_instrument.resample_vector_npix">
<code class="descclassname">firefly_instrument.</code><code class="descname">resample_vector_npix</code><span class="sig-paren">(</span><em>outRange=None</em>, <em>dx=None</em>, <em>log=False</em>, <em>base=10.0</em>, <em>default=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/firefly_instrument.html#resample_vector_npix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#firefly_instrument.resample_vector_npix" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine the number of pixels needed to resample the vector.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first docutils">
<dt>outRange (list or np.ndarray) <span class="classifier-delimiter">:</span> <span class="classifier">Two-element array with the</span></dt>
<dd>starting and ending x coordinate of the pixel centers to
divide into pixels of a given width.  If <em>log</em> is True, this
must still be the linear value of the x coordinate, not
log(x)!.</dd>
</dl>
<p>dx (float) : Linear or logarithmic pixel width.
log (bool) : Flag that the range should be logarithmically</p>
<blockquote>
<div>binned.</div></blockquote>
<p>base (float) : Base for the logarithm
default (int) : Default number of pixels to use.  The default is</p>
<blockquote class="last">
<div>returned if either <em>outRange</em> or <em>dx</em> are not provided.</div></blockquote>
</dd>
<dt>Returns:</dt>
<dd>int, np.ndarray: Returns two objects: The number of pixels to
cover <em>outRange</em> with pixels of width <em>dx</em> and the adjusted
range such that number of pixels of size dx is the exact integer.</dd>
<dt>Raises:</dt>
<dd>ValueError: Raised if the range is not a two-element vector</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="firefly_instrument.spectral_coordinate_step">
<code class="descclassname">firefly_instrument.</code><code class="descname">spectral_coordinate_step</code><span class="sig-paren">(</span><em>wave</em>, <em>log=False</em>, <em>base=10.0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/firefly_instrument.html#spectral_coordinate_step"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#firefly_instrument.spectral_coordinate_step" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sampling step for the input wavelength vector.</p>
<p>If the sampling is logarithmic, return the change in the logarithm
of the wavelength; otherwise, return the linear step in angstroms.</p>
<dl class="docutils">
<dt>Args: </dt>
<dd><dl class="first last docutils">
<dt>wave (np.ndarray): Wavelength coordinates of each spectral</dt>
<dd>channel in angstroms.</dd>
<dt>log (bool): (<strong>Optional</strong>) Input spectrum has been sampled</dt>
<dd>geometrically.</dd>
<dt>base (float): (<strong>Optional</strong>) If sampled geometrically, the</dt>
<dd>sampling is done using a logarithm with this base.  For
natural logarithm, use np.exp(1).</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>float: Spectral sampling step in either angstroms (log=False) or
the step in log(angstroms).</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="firefly_instrument.spectral_resolution">
<em class="property">class </em><code class="descclassname">firefly_instrument.</code><code class="descname">spectral_resolution</code><span class="sig-paren">(</span><em>wave</em>, <em>sres</em>, <em>log10=False</em>, <em>interp_ext='extrapolate'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/firefly_instrument.html#spectral_resolution"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#firefly_instrument.spectral_resolution" title="Permalink to this definition">¶</a></dt>
<dd><p>Container class for the resolution, <span class="math">\(R =
\lambda/\Delta\lambda\)</span>, of a spectrum.  The primary functionality is
to determine the parameters necessary to match the resolution of one
spectrum to another.  It can also be used as a function to
interpolate the spectral resolution at a given wavelenth.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>wave (np.ndarray): A 1D vector with the wavelength in</dt>
<dd>angstroms.  The sampling may be either in linear steps of
wavelength or <span class="math">\(\log_{10}\)</span> steps.</dd>
<dt>sres (np.ndarray): A 1D vector with the spectral resolution,</dt>
<dd><span class="math">\(R\)</span>, sampled at the positions of the provided
wavelength vector.</dd>
<dt>log10 (bool): (<strong>Optional</strong>) Flag that the spectrum has been</dt>
<dd>binned logarithmically (base 10) in wavelength</dd>
<dt>interp_ext (int or str): (<strong>Optional</strong>) The value to pass as</dt>
<dd><em>ext</em> to the interpolator, which defines its behavior when
attempting to sample the spectral resolution beyond where it
is defined.  See
<a class="reference external" href="http://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.InterpolatedUnivariateSpline.html">scipy.interpolate.InterpolatedUnivariateSpline</a>.  Default
is to extrapolate.</dd>
</dl>
</dd>
<dt>Raises:</dt>
<dd><dl class="first last docutils">
<dt>ValueError: Raised if <em>wave</em> is not a 1D vector or if <em>wave</em> and</dt>
<dd><em>sres</em> do not have the same shape.</dd>
</dl>
</dd>
<dt>Attributes:</dt>
<dd><dl class="first docutils">
<dt>interpolator</dt>
<dd>(<a class="reference external" href="http://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.InterpolatedUnivariateSpline.html">scipy.interpolate.InterpolatedUnivariateSpline</a>): An
object used to interpolate the spectral resolution at any
given wavelength.  The interpolation is hard-wired to be
<strong>linear</strong> and its extrapolation behavior is defined by
<em>interp_ext</em>.  The wavelength and resolution vectors are
held by this object for later reference if needed.</dd>
<dt>log10 (bool): Flag that the spectrum has been binned</dt>
<dd>logarithmically (base 10) in wavelength</dd>
<dt>cnst (<code class="xref py py-class docutils literal"><span class="pre">mangadap.util.constants</span></code>): Used to define the</dt>
<dd>conversion factor between a Gaussian sigma and FWHM</dd>
</dl>
<p>c (float): The speed of light; provided by <a class="reference external" href="http://docs.astropy.org/en/stable/constants/index.html">astropy.constants</a>.
dv (float): The velocity step per pixel in km/s.  Defined using</p>
<blockquote>
<div><a class="reference internal" href="#firefly_instrument.spectrum_velocity_scale" title="firefly_instrument.spectrum_velocity_scale"><code class="xref py py-func docutils literal"><span class="pre">spectrum_velocity_scale()</span></code></a> if <code class="xref py py-attr docutils literal"><span class="pre">log10</span></code> is True;
otherwise set to None.</div></blockquote>
<dl class="last docutils">
<dt>dw (float): The wavelength step per pixel in angstroms.  Defined</dt>
<dd>as the wavelength step between the first two pixels if
<code class="xref py py-attr docutils literal"><span class="pre">log10</span></code> is False; otherwise set to None.</dd>
<dt>min_sig (float): Minimum standard deviation allowed for the</dt>
<dd>kernel used to match two spectral resolutions.  See
<a class="reference internal" href="#firefly_instrument.spectral_resolution.GaussianKernelDifference" title="firefly_instrument.spectral_resolution.GaussianKernelDifference"><code class="xref py py-func docutils literal"><span class="pre">GaussianKernelDifference()</span></code></a>.</dd>
<dt>sig_pd (np.ndarray): The standard deviation in pixels</dt>
<dd>required to match the spectral resolution of this object to
the resolution defined by a different spectral_resolution
object.  See <a class="reference internal" href="#firefly_instrument.spectral_resolution.GaussianKernelDifference" title="firefly_instrument.spectral_resolution.GaussianKernelDifference"><code class="xref py py-func docutils literal"><span class="pre">GaussianKernelDifference()</span></code></a>.</dd>
<dt>sig_mask (np.ndarray): A <em>uint</em> vector used to identify</dt>
<dd>measurements of <code class="xref py py-attr docutils literal"><span class="pre">sig_pd</span></code> that should <strong>not</strong> be used
to match the spectral resolution of this object to the
resolution defined by a different spectral_resolution
object.  See <a class="reference internal" href="#firefly_instrument.spectral_resolution.GaussianKernelDifference" title="firefly_instrument.spectral_resolution.GaussianKernelDifference"><code class="xref py py-func docutils literal"><span class="pre">GaussianKernelDifference()</span></code></a>.</dd>
<dt>sig_vo (float): A constant offset of the kernal standard</dt>
<dd>deviation <strong>in km/s</strong> that has been applied to
<code class="xref py py-attr docutils literal"><span class="pre">sig_pd</span></code>.  See <a class="reference internal" href="#firefly_instrument.spectral_resolution.GaussianKernelDifference" title="firefly_instrument.spectral_resolution.GaussianKernelDifference"><code class="xref py py-func docutils literal"><span class="pre">GaussianKernelDifference()</span></code></a>.</dd>
</dl>
</dd>
</dl>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The default behavior of the interpolator is to extrapolate the
input spectral resolution vector when trying to sample from
regions beyond where it is sampled.  Use <em>interp_ext</em> change
this; see <a class="reference external" href="http://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.InterpolatedUnivariateSpline.html">scipy.interpolate.InterpolatedUnivariateSpline</a>.</p>
</div>
<dl class="method">
<dt id="firefly_instrument.spectral_resolution.GaussianKernelDifference">
<code class="descname">GaussianKernelDifference</code><span class="sig-paren">(</span><em>new_sres</em>, <em>no_offset=True</em>, <em>min_sig_pix=0.0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/firefly_instrument.html#spectral_resolution.GaussianKernelDifference"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#firefly_instrument.spectral_resolution.GaussianKernelDifference" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine the parameters of a Gaussian kernel required to
convert the resolution of this object to the resolution of a
different the <a class="reference internal" href="#firefly_instrument.spectral_resolution" title="firefly_instrument.spectral_resolution"><code class="xref py py-class docutils literal"><span class="pre">spectral_resolution</span></code></a> object, <em>new_sres</em>.</p>
<p>The spectral resolution is defined as <span class="math">\(R =
\lambda/\Delta\lambda\)</span>, where <span class="math">\(\Delta\lambda\)</span> is the FWHM
of the spectral resolution element.  The standard deviation of
the resolution element in angstroms is then</p>
<div class="math">
\[\sigma_\lambda = \frac{\lambda}{f R}, \ \ {\rm where} \ \  f
= \frac{{\rm FWHM_\lambda}}{\sigma_\lambda}.\]</div>
<p>Assuming a Gaussian (in angstroms) line-spread function:</p>
<div class="math">
\[\sigma^2_{\lambda,2} = \sigma^2_{\lambda,1} +
\sigma^2_{\lambda,d}\]</div>
<p>such that</p>
<div class="math">
\[\sigma^2_{\lambda,d} = \left(\frac{\lambda}{f}\right)^2
(R^{-2}_2 - R^{-2}_1)\]</div>
<p>is the defining parameter of the Gaussian kernel needed to take
a spectrum of resolution <span class="math">\(R_1\)</span> to one with a resolution of
<span class="math">\(R_2\)</span>.</p>
<p>For input to <a class="reference internal" href="#firefly_instrument.convolution_variable_sigma" title="firefly_instrument.convolution_variable_sigma"><code class="xref py py-func docutils literal"><span class="pre">convolution_variable_sigma()</span></code></a>, the
<em>wavelength-dependent</em> parameter of the Gaussian kernel is
converted to pixels.  This function allows for the input spectra
to be linearly sampled in angstroms or log10(angstroms).  For
the former (<em>log10=False</em>),</p>
<div class="math">
\[\sigma^2_{p,d} = \left(\frac{\lambda}{f\
\delta\lambda}\right)^2 (R^{-2}_2 - R^{-2}_1)\]</div>
<p>where <span class="math">\(\delta\lambda\)</span> is the size of the pixel in
angstroms.  If the units are log10(angstrom) (<em>log10=True</em>), we
approximate the velocity width of each pixel to be <span class="math">\(\delta
v = c \ln(10.0) (\log\lambda[1]-\log\lambda[0])\)</span>, such that</p>
<div class="math">
\[\begin{split}\sigma^2_{p,d} &amp;= \left(\frac{c}{ \delta v \lambda}\right)^2
\sigma^2_{\lambda,d} \\ &amp;= \left(\frac{c}{ f\ \delta
v}\right)^2 (R^{-2}_2 - R^{-2}_1)\ ;\end{split}\]</div>
<p><span class="math">\(c\)</span> is the speed of light in km/s.</p>
<p>The nominal use of this algorithm assumes <span class="math">\(R_1 \geq R_2\)</span>.
However, in practice, <a class="reference internal" href="#firefly_instrument.convolution_variable_sigma" title="firefly_instrument.convolution_variable_sigma"><code class="xref py py-func docutils literal"><span class="pre">convolution_variable_sigma()</span></code></a> only
uses a Gaussian kernel up to some minimum value of
<span class="math">\(\epsilon_\sigma\)</span>; below this, the kernel is assumed to be
a Delta function.  Therefore, as long as</p>
<div class="math">
\[\sigma_{p,d} \equiv \sigma^2_{p,d}/\sqrt{|\sigma^2_{p,d}|}
\geq -\epsilon_\sigma\ ,\]</div>
<p>the behavior of <a class="reference internal" href="#firefly_instrument.convolution_variable_sigma" title="firefly_instrument.convolution_variable_sigma"><code class="xref py py-func docutils literal"><span class="pre">convolution_variable_sigma()</span></code></a> should not be
affected.</p>
<p>Even so, there may be spectral regions that do not have
<span class="math">\(\sigma_{p,d} \geq -\epsilon_\sigma\)</span>; for such spectral
regions there are three choices:</p>
<blockquote>
<div><p>(<strong>Option 1</strong>) trim the spectral range to only those
spectral regions where the existing resolution is better
than the target resolution,</p>
<p>(<strong>Option 2</strong>) match the existing resolution to the target
resolution up to some constant offset that must be accounted
for in subsequent analyses, or</p>
<p>(<strong>Option 3</strong>) allow for a wavelength dependent difference
in the spectral resolution that must be accounted for in
subsequent analyses.</p>
</div></blockquote>
<p>The choice of either Option 1 or 2 is selected by setting
<em>no_offset</em> to, respectively, True or False; Option 1 is the
default behavior.  Currently, Option 3 is not allowed.</p>
<p>For Option 1, pixels with <span class="math">\(\sigma_{p,d} &lt;
-\epsilon_\sigma\)</span> are masked (<em>sigma_mask = 1</em>); however, the
returned values of <span class="math">\(\sigma_{p,d}\)</span> are left unchanged.</p>
<p>For Option 2, we define</p>
<div class="math">
\[\sigma^2_{v,o} = -{\rm min}(\sigma^2_{v,d}) - {\rm
max}(\epsilon_\sigma \delta v)^2\]</div>
<p>where <span class="math">\(\delta v\)</span> is constant for the logarithmically
binned spectrum and is wavelength dependent for the linearly
binned spectra; in the latter case, the velocity step is
determined for each pixel:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">_wave</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wave</span><span class="p">()</span>
<span class="n">dv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="o">*</span> <span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="p">(</span><span class="n">_wave</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">_wave</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="n">_wave</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">_wave</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
</pre></div>
</div>
<p>If <span class="math">\(\sigma^2_{v,o} &gt; 0.0\)</span>, it must be that <span class="math">\({\rm
min}(\sigma^2_{v,d}) &lt; -{\rm max}(\epsilon_\sigma \delta v)^2\)</span>,
such that an offset should be applied.  In that case, the
returned kernel parameters are</p>
<div class="math">
\[\sigma^\prime_{v,d} = \sqrt{\sigma^2_{v,d} +
\sigma^2_{v,o}}\ .\]</div>
<p>with the units converted to pixels using the equations above, no
pixels are masked, and <span class="math">\(\sqrt{\sigma^2_{v,o}}\)</span> is returned
for the offset.  Otherwise, the offset is set to 0.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>new_sres (<a class="reference internal" href="#firefly_instrument.spectral_resolution" title="firefly_instrument.spectral_resolution"><code class="xref py py-class docutils literal"><span class="pre">spectral_resolution</span></code></a>): Spectral resolution</dt>
<dd>to match to.</dd>
<dt>no_offset (bool): (<strong>Optional</strong>) Force :math:<a href="#id15"><span class="problematic" id="id16">`</span></a>sigma^2_{v,o}</dt>
<dd>= 0` by masking regions with <span class="math">\(\sigma_{p,d} &lt;
-\epsilon_\sigma\)</span>; i.e., the value of this arguments
selects Option 1 (True) or Option 2 (False).</dd>
<dt>min_sig_pix (float): (<strong>Optional</strong>) Minimum value of the</dt>
<dd>standard deviation allowed before assuming the kernel is
a Delta function.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="firefly_instrument.spectral_resolution.adjusted_resolution">
<code class="descname">adjusted_resolution</code><span class="sig-paren">(</span><em>indx=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/firefly_instrument.html#spectral_resolution.adjusted_resolution"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#firefly_instrument.spectral_resolution.adjusted_resolution" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the resolution that should result from applying
<a class="reference internal" href="#firefly_instrument.convolution_variable_sigma" title="firefly_instrument.convolution_variable_sigma"><code class="xref py py-func docutils literal"><span class="pre">convolution_variable_sigma()</span></code></a> to the spectrum associated
with this spectral resolution object using <code class="xref py py-attr docutils literal"><span class="pre">sigma_pd</span></code>.
I.e., calculate:</p>
<div class="math">
\[R_2 = \left[ \left(\frac{f}{c}\right)^2 \sigma^2_{v,d} +
R^{-2}_1\right]^{-1/2}\ . \]</div>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>indx (tuple): (<strong>Optional</strong>) Selection tuple used to return</dt>
<dd>a subset of the full resolution vector.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>np.ndarray: The (full or selected) vector with the
adjusted resolution.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="firefly_instrument.spectral_resolution.match">
<code class="descname">match</code><span class="sig-paren">(</span><em>new_sres</em>, <em>no_offset=True</em>, <em>min_sig_pix=0.0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/firefly_instrument.html#spectral_resolution.match"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#firefly_instrument.spectral_resolution.match" title="Permalink to this definition">¶</a></dt>
<dd><p>Currently only an alias for <a class="reference internal" href="#firefly_instrument.spectral_resolution.GaussianKernelDifference" title="firefly_instrument.spectral_resolution.GaussianKernelDifference"><code class="xref py py-func docutils literal"><span class="pre">GaussianKernelDifference()</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="firefly_instrument.spectral_resolution.offset_GaussianKernelDifference">
<code class="descname">offset_GaussianKernelDifference</code><span class="sig-paren">(</span><em>offset</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/firefly_instrument.html#spectral_resolution.offset_GaussianKernelDifference"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#firefly_instrument.spectral_resolution.offset_GaussianKernelDifference" title="Permalink to this definition">¶</a></dt>
<dd><p>If the properties required to match the resolution of one
spectrum to another has already been calculated (see
<a class="reference internal" href="#firefly_instrument.spectral_resolution.GaussianKernelDifference" title="firefly_instrument.spectral_resolution.GaussianKernelDifference"><code class="xref py py-func docutils literal"><span class="pre">GaussianKernelDifference()</span></code></a>), this allows for one to apply
an additional offset.  The additional offset <strong>must</strong> be in km/s
(not pixels).</p>
<p>The offset is applied in quadrature; however, the offset can be
negative such that one can reduce <code class="xref py py-attr docutils literal"><span class="pre">sig_pd</span></code>.  Once
converted to km/s, the offset is applied by calculating:</p>
<div class="math">
\[\sigma^{\prime\ 2}_{v,d} = \sigma^{2}_{v,d} +
\sigma_{off}|\sigma_{off}|\ .\]</div>
<p><code class="xref py py-attr docutils literal"><span class="pre">sig_vo</span></code> is adjusted in the same way, and the change in
<span class="math">\(\sigma^{\prime\ 2}_{v,d}\)</span> is then propagated to
<code class="xref py py-attr docutils literal"><span class="pre">sig_pd</span></code> and <code class="xref py py-attr docutils literal"><span class="pre">sig_mask</span></code>.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>offset (float): Value of the standard deviation in km/s to</dt>
<dd>add in quadrature to a previously calculated
<code class="xref py py-attr docutils literal"><span class="pre">sig_pd</span></code>.</dd>
</dl>
</dd>
<dt>Raises:</dt>
<dd><dl class="first last docutils">
<dt>ValueError: Raised if the kernel properties have not yet</dt>
<dd>been defined.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="firefly_instrument.spectral_resolution.sres">
<code class="descname">sres</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/firefly_instrument.html#spectral_resolution.sres"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#firefly_instrument.spectral_resolution.sres" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the resolution vector; held by <code class="xref py py-attr docutils literal"><span class="pre">interpolator</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="firefly_instrument.spectral_resolution.wave">
<code class="descname">wave</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/firefly_instrument.html#spectral_resolution.wave"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#firefly_instrument.spectral_resolution.wave" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the wavelength vector; held by <code class="xref py py-attr docutils literal"><span class="pre">interpolator</span></code>.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="firefly_instrument.spectrum_velocity_scale">
<code class="descclassname">firefly_instrument.</code><code class="descname">spectrum_velocity_scale</code><span class="sig-paren">(</span><em>wave</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/firefly_instrument.html#spectrum_velocity_scale"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#firefly_instrument.spectrum_velocity_scale" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine the velocity sampling of an input wavelength coordinate
vector.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The wavelength vector is assumed to be geometrically sampled!
However, the input units expected to be in angstroms, not, e.g.,
log(angstrom).</p>
</div>
<dl class="docutils">
<dt>Args: </dt>
<dd><dl class="first last docutils">
<dt>wave (np.ndarray): Wavelength coordinates of each spectral</dt>
<dd>channel in angstroms.  It is expected that the spectrum has
been sampled geometrically</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>float: Velocity scale of the spectrum in km/s.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="firefly_instrument.where_not">
<code class="descclassname">firefly_instrument.</code><code class="descname">where_not</code><span class="sig-paren">(</span><em>indx</em>, <em>size</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/firefly_instrument.html#where_not"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#firefly_instrument.where_not" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a tuple with the indices of a vector that were <em>not</em> selected
by a call to <a href="#id17"><span class="problematic" id="id18">`np.where`_</span></a>.  <strong>The function currently only works
for 1D vectors.</strong></p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>indx (tuple): Tuple returned by a call to <a href="#id19"><span class="problematic" id="id20">`np.where`_</span></a> for a</dt>
<dd>1D vector.</dd>
<dt>size (int): Length of the original vector in the call to</dt>
<dd><a href="#id21"><span class="problematic" id="id22">`np.where`_</span></a>.</dd>
</dl>
</dd>
</dl>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Performs <strong>no</strong> checks of the input.</p>
</div>
</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h4>Previous topic</h4>
  <p class="topless"><a href="firefly_dust.html"
                        title="previous chapter">firefly dust</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="firefly_library.html"
                        title="next chapter">firefly library</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/firefly_instrument.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="firefly_library.html" title="firefly library"
             >next</a> |</li>
        <li class="right" >
          <a href="firefly_dust.html" title="firefly dust"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">FIREFLY - Fitting Iteratively for Relative Likelihood Analysis 1.0.4 documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2017, Johan Comparat.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.5.3.
    </div>
  </body>
</html>