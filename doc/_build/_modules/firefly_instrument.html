<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>firefly_instrument &#8212; FIREFLY - Fitting Iteratively for Relative Likelihood Analysis 1.0.4 documentation</title>
    
    <link rel="stylesheet" href="../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.0.4',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">FIREFLY - Fitting Iteratively for Relative Likelihood Analysis 1.0.4 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for firefly_instrument</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">Provides a set of functions to handle instrumental effects.</span>

<span class="sd">:func:`log_rebin` has been pulled from</span>
<span class="sd">:mod:`mangadap.contrib.ppxf_util.py` and modified.</span>

<span class="sd">*Source location*:</span>
<span class="sd">    $MANGADAP_DIR/python/mangadap/util/instrument.py</span>

<span class="sd">*Python2/3 compliance*::</span>

<span class="sd">    from __future__ import division</span>
<span class="sd">    from __future__ import print_function</span>
<span class="sd">    from __future__ import absolute_import</span>
<span class="sd">    </span>
<span class="sd">    import sys</span>
<span class="sd">    if sys.version &gt; &#39;3&#39;:</span>
<span class="sd">        long = int</span>

<span class="sd">*Imports*::</span>

<span class="sd">    import warnings</span>
<span class="sd">    import numpy</span>
<span class="sd">    from scipy.interpolate import InterpolatedUnivariateSpline</span>
<span class="sd">    import astropy.constants</span>

<span class="sd">*Revision history*:</span>
<span class="sd">    | **24 May 2017 - Implemented the new downgrader version (D. Goddard)</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">absolute_import</span>

<span class="kn">import</span> <span class="nn">sys</span>
<span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version</span> <span class="o">&gt;</span> <span class="s1">&#39;3&#39;</span><span class="p">:</span>
    <span class="n">long</span> <span class="o">=</span> <span class="nb">int</span>

<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="k">import</span> <span class="n">InterpolatedUnivariateSpline</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">astropy</span>
<span class="kn">from</span> <span class="nn">astropy.constants</span> <span class="k">import</span> <span class="n">c</span> <span class="k">as</span> <span class="n">speedOfLight</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">speedOfLight</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s1">&#39;km/s&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">value</span>
<span class="kn">from</span> <span class="nn">constants</span> <span class="k">import</span> <span class="o">*</span>

<div class="viewcode-block" id="where_not"><a class="viewcode-back" href="../firefly_instrument.html#firefly_instrument.where_not">[docs]</a><span class="k">def</span> <span class="nf">where_not</span><span class="p">(</span><span class="n">indx</span><span class="p">,</span> <span class="n">size</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Return a tuple with the indices of a vector that were *not* selected</span>
<span class="sd">	by a call to `np.where`_.  **The function currently only works</span>
<span class="sd">	for 1D vectors.**</span>

<span class="sd">	Args:</span>
<span class="sd">		indx (tuple): Tuple returned by a call to `np.where`_ for a</span>
<span class="sd">			1D vector.</span>
<span class="sd">		size (int): Length of the original vector in the call to</span>
<span class="sd">			`np.where`_.</span>

<span class="sd">	.. warning:: </span>
<span class="sd">		Performs **no** checks of the input.</span>

<span class="sd">	&quot;&quot;&quot;</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">size</span><span class="p">),</span> <span class="n">indx</span><span class="p">[</span><span class="mi">0</span><span class="p">]),)</span></div>
   
<div class="viewcode-block" id="spectral_coordinate_step"><a class="viewcode-back" href="../firefly_instrument.html#firefly_instrument.spectral_coordinate_step">[docs]</a><span class="k">def</span> <span class="nf">spectral_coordinate_step</span><span class="p">(</span><span class="n">wave</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="mf">10.0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the sampling step for the input wavelength vector.</span>

<span class="sd">    If the sampling is logarithmic, return the change in the logarithm</span>
<span class="sd">    of the wavelength; otherwise, return the linear step in angstroms.</span>

<span class="sd">    Args: </span>
<span class="sd">        wave (np.ndarray): Wavelength coordinates of each spectral</span>
<span class="sd">            channel in angstroms.</span>
<span class="sd">        log (bool): (**Optional**) Input spectrum has been sampled</span>
<span class="sd">            geometrically.</span>
<span class="sd">        base (float): (**Optional**) If sampled geometrically, the</span>
<span class="sd">            sampling is done using a logarithm with this base.  For</span>
<span class="sd">            natural logarithm, use np.exp(1).</span>

<span class="sd">    Returns:</span>
<span class="sd">        float: Spectral sampling step in either angstroms (log=False) or</span>
<span class="sd">        the step in log(angstroms).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">wave</span><span class="p">))</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">base</span><span class="p">)</span> <span class="k">if</span> <span class="n">log</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">wave</span><span class="p">)</span>
<span class="c1">#    print(&#39;mean: &#39;, np.mean(dw))</span>
<span class="c1">#    print(&#39;sdev: &#39;, np.std(dw))</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dw</span><span class="p">)</span></div>
<span class="c1">#    return (np.diff(np.log(wave[0:2]))/np.log(base) if log else np.diff(wave[0:2]))[0]</span>


<div class="viewcode-block" id="spectrum_velocity_scale"><a class="viewcode-back" href="../firefly_instrument.html#firefly_instrument.spectrum_velocity_scale">[docs]</a><span class="k">def</span> <span class="nf">spectrum_velocity_scale</span><span class="p">(</span><span class="n">wave</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determine the velocity sampling of an input wavelength coordinate</span>
<span class="sd">    vector.</span>
<span class="sd">    </span>
<span class="sd">    .. note::</span>
<span class="sd">        The wavelength vector is assumed to be geometrically sampled!</span>
<span class="sd">        However, the input units expected to be in angstroms, not, e.g.,</span>
<span class="sd">        log(angstrom).</span>

<span class="sd">    Args: </span>
<span class="sd">        wave (np.ndarray): Wavelength coordinates of each spectral</span>
<span class="sd">            channel in angstroms.  It is expected that the spectrum has</span>
<span class="sd">            been sampled geometrically</span>

<span class="sd">    Returns:</span>
<span class="sd">        float: Velocity scale of the spectrum in km/s.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">astropy</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s1">&#39;km/s&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="o">*</span><span class="n">spectral_coordinate_step</span><span class="p">(</span><span class="n">wave</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                                         <span class="n">base</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mf">1.</span><span class="p">))</span></div>


<div class="viewcode-block" id="convolution_integral_element"><a class="viewcode-back" href="../firefly_instrument.html#firefly_instrument.convolution_integral_element">[docs]</a><span class="k">class</span> <span class="nc">convolution_integral_element</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Support class for variable sigma convolution.  See</span>
<span class="sd">    :func:`convolution_variable_sigma`.</span>

<span class="sd">    OUT OF DATE; DO NOT USE</span>

<span class="sd">    Args:</span>
<span class="sd">        y (np.ndarray): Vector to convolve</span>
<span class="sd">        sigma (np.ndarray): Coordinate-dependent standard deviation of the</span>
<span class="sd">            Gaussian kernel</span>
<span class="sd">        ye (np.ndarray): (**Optional**) Error in the vector to</span>
<span class="sd">            convolve</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: Raised if *y* is not a 1D vector, or if the shape of</span>
<span class="sd">            *y* and *sigma* (and *ye* if provided) are different.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        x (np.ndarray): Pixel coordinate vector</span>
<span class="sd">        y (np.ndarray): Vector to convolve</span>
<span class="sd">        ye (np.ndarray): Error in the vector to convolve</span>
<span class="sd">        sigma (np.ndarray): Coordinate-dependent standard deviation of the</span>
<span class="sd">            Gaussian kernel</span>
<span class="sd">        norm (np.ndarray): Gaussian normalization; calculated once for</span>
<span class="sd">            efficiency</span>

<span class="sd">    .. todo::</span>

<span class="sd">        - Allow to switch to pixel sampled Gaussian kernel?</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">ye</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;y must be a 1D array!&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">sigma</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;y and sigma must have the same shape!&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ye</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">ye</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;y and ye must have the same shape!&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">sigma</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ye</span> <span class="o">=</span> <span class="n">ye</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span> <span class="o">=</span> <span class="n">sigma</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma</span>


    <span class="k">def</span> <span class="nf">_get_kernel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xc</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate the kernel vector when centered at *xc*.</span>

<span class="sd">        .. todo::</span>

<span class="sd">            - Function is about 30% slower when using erf() as opposed</span>
<span class="sd">              to exp().  erf() needed when sigma is small, but may be</span>
<span class="sd">              efficient to include some decision on when it&#39;s safe to</span>
<span class="sd">              use the quick way.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">-</span><span class="n">xc</span><span class="p">)</span>
        <span class="n">gf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">d</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="p">)</span> 
        <span class="n">close_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">gf</span> <span class="o">&lt;</span> <span class="mf">50.0</span><span class="p">)</span>
<span class="c1">#        outkern = np.exp(-0.5*gf[close_value])/self.norm[close_value]</span>
        <span class="n">outkern</span> <span class="o">=</span> <span class="p">(</span><span class="n">erf</span><span class="p">((</span><span class="n">d</span><span class="p">[</span><span class="n">close_value</span><span class="p">]</span><span class="o">+</span><span class="mf">0.5</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="p">[</span><span class="n">close_value</span><span class="p">])</span>
                    <span class="o">-</span> <span class="n">erf</span><span class="p">((</span><span class="n">d</span><span class="p">[</span><span class="n">close_value</span><span class="p">]</span><span class="o">-</span><span class="mf">0.5</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="p">[</span><span class="n">close_value</span><span class="p">]))</span><span class="o">/</span><span class="mf">2.</span>
        <span class="k">return</span> <span class="n">close_value</span><span class="p">,</span> <span class="n">outkern</span>


<span class="c1">#    def _get_kernel(self, xc):</span>
<span class="c1">#        &quot;&quot;&quot;Calculate the kernel vector when centered at *xc*.&quot;&quot;&quot;</span>
<span class="c1">#        return np.exp(-0.5*np.square((self.x-xc)/self.sigma))/self.norm</span>


    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xc</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the weighted mean of :attr:`y`, where the weights are</span>
<span class="sd">        defined by a Gaussian with standard deviation :attr:`sigma` and</span>
<span class="sd">        centered at xc.</span>

<span class="sd">        Args:</span>
<span class="sd">            xc (float): Center for the Gaussian weighting function</span>

<span class="sd">        Returns:</span>
<span class="sd">            float: The weighted mean of :attr:`y`</span>
<span class="sd">        &quot;&quot;&quot;</span>
<span class="c1">#        kernel = self._get_kernel(xc)</span>
<span class="c1">#        return np.sum(self.y*kernel) / np.sum(kernel)</span>
        <span class="n">close_array</span><span class="p">,</span> <span class="n">kernel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_kernel</span><span class="p">(</span><span class="n">xc</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">close_array</span><span class="p">]</span><span class="o">*</span><span class="n">kernel</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">kernel</span><span class="p">)</span>

        <span class="c1"># Need to test equivalence and speed of these two implementations</span>
<span class="c1">#        return integrate.simps(self.y*kernel) / integrate.simps(kernel)</span>


<div class="viewcode-block" id="convolution_integral_element.error"><a class="viewcode-back" href="../firefly_instrument.html#firefly_instrument.convolution_integral_element.error">[docs]</a>    <span class="k">def</span> <span class="nf">error</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xc</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the error in the weighted mean of :attr:`y` using</span>
<span class="sd">        nominal error propagation.  The weights are defined by a</span>
<span class="sd">        Gaussian with standard deviation :attr:`sigma` and centered at</span>
<span class="sd">        xc.</span>

<span class="sd">        Args:</span>
<span class="sd">            xc (float): Center for the Gaussian weighting function</span>

<span class="sd">        Returns:</span>
<span class="sd">            float: The error in the weighted mean of :attr:`y`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">close_array</span><span class="p">,</span> <span class="n">kernel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_kernel</span><span class="p">(</span><span class="n">xc</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ye</span><span class="p">[</span><span class="n">close_array</span><span class="p">]</span><span class="o">*</span><span class="n">kernel</span><span class="p">))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">kernel</span><span class="p">))</span></div></div>
<span class="c1">#        kernel = self._get_kernel(xc)</span>
<span class="c1">#        return np.sqrt(np.sum(np.square(self.ye*kernel)) / np.sum(kernel))</span>


<div class="viewcode-block" id="VariableGaussianKernel"><a class="viewcode-back" href="../firefly_instrument.html#firefly_instrument.VariableGaussianKernel">[docs]</a><span class="k">class</span> <span class="nc">VariableGaussianKernel</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Support class for variable sigma convolution.  See</span>
<span class="sd">    :func:`convolution_variable_sigma`.</span>

<span class="sd">    Stolen from M. Cappellari&#39;s gaussian_filter1d function.</span>

<span class="sd">    Args:</span>
<span class="sd">        y (np.ndarray): Vector to convolve</span>
<span class="sd">        sigma (np.ndarray): Coordinate-dependent standard deviation of the</span>
<span class="sd">            Gaussian kernel</span>
<span class="sd">        ye (np.ndarray): (**Optional**) Error in the vector to</span>
<span class="sd">            convolve</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: Raised if *y* is not a 1D vector, or if the shape of</span>
<span class="sd">            *y* and *sigma* (and *ye* if provided) are different.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        x (np.ndarray): Pixel coordinate vector</span>
<span class="sd">        y (np.ndarray): Vector to convolve</span>
<span class="sd">        ye (np.ndarray): Error in the vector to convolve</span>
<span class="sd">        sigma (np.ndarray): Coordinate-dependent standard deviation of the</span>
<span class="sd">            Gaussian kernel</span>
<span class="sd">        norm (np.ndarray): Gaussian normalization; calculated once for</span>
<span class="sd">            efficiency</span>

<span class="sd">    .. todo::</span>

<span class="sd">        - Allow to switch to pixel sampled Gaussian kernel?</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">minsig</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">nsig</span><span class="o">=</span><span class="mf">3.0</span><span class="p">,</span> <span class="n">integral</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">sigma</span><span class="o">.</span><span class="n">size</span>                                     <span class="c1"># Vector length</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span> <span class="o">=</span> <span class="n">sigma</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="nb">min</span><span class="o">=</span><span class="n">minsig</span><span class="p">)</span>                     <span class="c1"># Force sigmas to minimum </span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">nsig</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="p">)))</span>   <span class="c1"># Kernel covers up to nsig*sigma</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">m</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span> <span class="o">+</span> <span class="mi">1</span>                                   <span class="c1"># Kernel length</span>
        <span class="n">x2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">))</span>   <span class="c1"># X^2 for kernel</span>

        <span class="c1"># Kernel will have size m x n</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kernel</span> <span class="o">=</span> <span class="p">(</span><span class="n">erf</span><span class="p">((</span><span class="n">x2</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]</span><span class="o">+</span><span class="mf">0.5</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="p">)</span> 
                            <span class="o">-</span> <span class="n">erf</span><span class="p">((</span><span class="n">x2</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]</span><span class="o">-</span><span class="mf">0.5</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="p">))</span><span class="o">/</span><span class="mf">2.</span> <span class="k">if</span> <span class="n">integral</span> <span class="k">else</span> \
                      <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">x2</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="p">)))</span> 

        <span class="bp">self</span><span class="o">.</span><span class="n">kernel</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kernel</span><span class="p">,</span> <span class="mi">0</span><span class="p">)[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>       <span class="c1"># Normalize kernel</span>


    <span class="k">def</span> <span class="nf">_check_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">ye</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make sure that the shapes are appropriate for the defined kernel.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;y must be a 1D array!&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">y</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;y and sigma must have the same shape!&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ye</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ye</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">ye</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;ye length does not must have the correct shape!&#39;</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">_create_a</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kernel</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">):</span>
            <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">:</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="o">+</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">a</span>


    <span class="k">def</span> <span class="nf">convolve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">ye</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_shape</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">ye</span><span class="o">=</span><span class="n">ye</span><span class="p">)</span>

        <span class="c1"># Create m copies of the shifted input function</span>
        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_a</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ye</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">kernel</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Construct the error</span>
        <span class="n">ae</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_a</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">ye</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">kernel</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ae</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">kernel</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span></div>


<div class="viewcode-block" id="convolution_variable_sigma"><a class="viewcode-back" href="../firefly_instrument.html#firefly_instrument.convolution_variable_sigma">[docs]</a><span class="k">def</span> <span class="nf">convolution_variable_sigma</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">ye</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">integral</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convolve a discretely sampled function :math:`y(x)` with a Gaussian</span>
<span class="sd">    kernel, :math:`g`, where the standard deviation of the kernel is a</span>
<span class="sd">    function of :math:`x`, :math:`\sigma(x)`.  Nominal calculations can</span>
<span class="sd">    be performed to propagate the error in the result; these</span>
<span class="sd">    calculations **do not** include the covariance between the pixels,</span>
<span class="sd">    which will mean that the calculations likely have significant error!</span>

<span class="sd">    The convolution is defined as:</span>

<span class="sd">    .. math::</span>

<span class="sd">        (y\ast g)(x) &amp;= \int_{-\infty}^{\infty} y(X)\ g(\sigma,x-X)\ dX \\</span>
<span class="sd">                     &amp;= \int_{-\infty}^{\infty} \frac{y(X)}{\sqrt{2\pi}\</span>
<span class="sd">                        \sigma(X)}\ \exp\left(-\frac{(x-X)^2}{2\</span>
<span class="sd">                        \sigma(X)^2}\right) dX .</span>

<span class="sd">    To minimize edge effects and account for the censoring of the data</span>
<span class="sd">    (finite range in :math:`x`), the convolution is actually calculated</span>
<span class="sd">    as a definite integral and normalized as follows:</span>

<span class="sd">    .. math::</span>

<span class="sd">        (y\ast g)(x) \sim\frac{</span>
<span class="sd">        \int_{x-n_\sigma*\sigma(x)}^{x+n_\sigma*\sigma(x)} y(X)\</span>
<span class="sd">        g(\sigma,x-X)\ dX}{</span>
<span class="sd">        \int_{x-n_\sigma*\sigma(x)}^{x+n_\sigma*\sigma(x)}</span>
<span class="sd">        g(\sigma,x-X)\ dX} .</span>

<span class="sd">    The above is identical to getting the weighted mean of :math:`y` at</span>
<span class="sd">    each position :math:`x`, where the weights are defined by a Gaussian</span>
<span class="sd">    kernel centered at :math:`x` with a variable dispersion.</span>

<span class="sd">    Use of this function requires:</span>
<span class="sd">        - *y* and *sigma* must be 1D vectors</span>
<span class="sd">        - *y* and *sigma* must be uniformly sampled on the same grid</span>
<span class="sd">        - *sigma* must be in pixel units.</span>

<span class="sd">    Args:</span>
<span class="sd">        y (np.ndarray): A uniformly sampled function to convolve.</span>
<span class="sd">        sigma (np.ndarray): The standard deviation of the Gaussian</span>
<span class="sd">            kernel sampled at the same positions as *y*.  The units of</span>
<span class="sd">            *sigma* **must** be in pixels.</span>
<span class="sd">        ye (np.ndarray): (**Optional**) Errors in the function</span>
<span class="sd">            :math:`y(x)`.</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.ndarray: Arrays with the convolved function :math:`(y\ast</span>
<span class="sd">        g)(x)` sampled at the same positions as the input :math:`x`</span>
<span class="sd">        vector and its error.  The second array will be returned as None</span>
<span class="sd">        if the error vector is not provided.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="c1">#    kernel = convolution_integral_element(y,sigma,ye=ye)</span>
<span class="c1">#    conv = np.array([kernel(x) for x in kernel.x])</span>
<span class="c1">#    if ye is None:</span>
<span class="c1">#        return conv</span>
<span class="c1">#    return conv, np.array([kernel.error(x) for x in kernel.x])</span>

    <span class="k">return</span> <span class="n">VariableGaussianKernel</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="n">integral</span><span class="o">=</span><span class="n">integral</span><span class="p">)</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">ye</span><span class="o">=</span><span class="n">ye</span><span class="p">)</span></div>


<div class="viewcode-block" id="spectral_resolution"><a class="viewcode-back" href="../firefly_instrument.html#firefly_instrument.spectral_resolution">[docs]</a><span class="k">class</span> <span class="nc">spectral_resolution</span><span class="p">:</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    </span>
<span class="sd">    Container class for the resolution, :math:`R =</span>
<span class="sd">    \lambda/\Delta\lambda`, of a spectrum.  The primary functionality is</span>
<span class="sd">    to determine the parameters necessary to match the resolution of one</span>
<span class="sd">    spectrum to another.  It can also be used as a function to</span>
<span class="sd">    interpolate the spectral resolution at a given wavelenth.</span>

<span class="sd">    Args:</span>
<span class="sd">        wave (np.ndarray): A 1D vector with the wavelength in</span>
<span class="sd">            angstroms.  The sampling may be either in linear steps of</span>
<span class="sd">            wavelength or :math:`\log_{10}` steps.</span>
<span class="sd">        sres (np.ndarray): A 1D vector with the spectral resolution,</span>
<span class="sd">            :math:`R`, sampled at the positions of the provided</span>
<span class="sd">            wavelength vector.</span>
<span class="sd">        log10 (bool): (**Optional**) Flag that the spectrum has been</span>
<span class="sd">            binned logarithmically (base 10) in wavelength</span>
<span class="sd">        interp_ext (int or str): (**Optional**) The value to pass as</span>
<span class="sd">            *ext* to the interpolator, which defines its behavior when</span>
<span class="sd">            attempting to sample the spectral resolution beyond where it</span>
<span class="sd">            is defined.  See</span>
<span class="sd">            `scipy.interpolate.InterpolatedUnivariateSpline`_.  Default</span>
<span class="sd">            is to extrapolate.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: Raised if *wave* is not a 1D vector or if *wave* and</span>
<span class="sd">            *sres* do not have the same shape.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        interpolator</span>
<span class="sd">            (`scipy.interpolate.InterpolatedUnivariateSpline`_): An</span>
<span class="sd">            object used to interpolate the spectral resolution at any</span>
<span class="sd">            given wavelength.  The interpolation is hard-wired to be</span>
<span class="sd">            **linear** and its extrapolation behavior is defined by</span>
<span class="sd">            *interp_ext*.  The wavelength and resolution vectors are</span>
<span class="sd">            held by this object for later reference if needed.</span>
<span class="sd">        log10 (bool): Flag that the spectrum has been binned</span>
<span class="sd">            logarithmically (base 10) in wavelength</span>
<span class="sd">        cnst (:class:`mangadap.util.constants`): Used to define the</span>
<span class="sd">            conversion factor between a Gaussian sigma and FWHM</span>
<span class="sd">        c (float): The speed of light; provided by `astropy.constants`_.</span>
<span class="sd">        dv (float): The velocity step per pixel in km/s.  Defined using</span>
<span class="sd">            :func:`spectrum_velocity_scale` if :attr:`log10` is True;</span>
<span class="sd">            otherwise set to None.</span>
<span class="sd">        dw (float): The wavelength step per pixel in angstroms.  Defined</span>
<span class="sd">            as the wavelength step between the first two pixels if</span>
<span class="sd">            :attr:`log10` is False; otherwise set to None.</span>
<span class="sd">        min_sig (float): Minimum standard deviation allowed for the</span>
<span class="sd">            kernel used to match two spectral resolutions.  See</span>
<span class="sd">            :func:`GaussianKernelDifference`.</span>
<span class="sd">        sig_pd (np.ndarray): The standard deviation in pixels</span>
<span class="sd">            required to match the spectral resolution of this object to</span>
<span class="sd">            the resolution defined by a different spectral_resolution</span>
<span class="sd">            object.  See :func:`GaussianKernelDifference`.</span>
<span class="sd">        sig_mask (np.ndarray): A *uint* vector used to identify</span>
<span class="sd">            measurements of :attr:`sig_pd` that should **not** be used</span>
<span class="sd">            to match the spectral resolution of this object to the</span>
<span class="sd">            resolution defined by a different spectral_resolution</span>
<span class="sd">            object.  See :func:`GaussianKernelDifference`.</span>
<span class="sd">        sig_vo (float): A constant offset of the kernal standard</span>
<span class="sd">            deviation **in km/s** that has been applied to</span>
<span class="sd">            :attr:`sig_pd`.  See :func:`GaussianKernelDifference`.</span>
<span class="sd">        </span>
<span class="sd">    .. todo::</span>

<span class="sd">        - Allow it to determine if the binning is linear or geometric,</span>
<span class="sd">          then use the *log10* keyword to distinguish between natural</span>
<span class="sd">          log and :math:`log_{10}` binning.</span>
<span class="sd">        - Allow for more than one type of line-spread function?</span>

<span class="sd">    .. warning::</span>

<span class="sd">        The default behavior of the interpolator is to extrapolate the</span>
<span class="sd">        input spectral resolution vector when trying to sample from</span>
<span class="sd">        regions beyond where it is sampled.  Use *interp_ext* change</span>
<span class="sd">        this; see `scipy.interpolate.InterpolatedUnivariateSpline`_.</span>

<span class="sd">    .. _scipy.interpolate.InterpolatedUnivariateSpline: http://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.InterpolatedUnivariateSpline.html</span>
<span class="sd">    .. _astropy.constants: http://docs.astropy.org/en/stable/constants/index.html</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wave</span><span class="p">,</span> <span class="n">sres</span><span class="p">,</span> <span class="n">log10</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">interp_ext</span><span class="o">=</span><span class="s1">&#39;extrapolate&#39;</span><span class="p">):</span>
        <span class="c1"># Check the sizes</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">wave</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;wave must be a 1D array!&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">wave</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">sres</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;wave and sres must have the same shape!&#39;</span><span class="p">)</span>

        <span class="c1"># k=1; always use linear interpolation</span>
        <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version</span> <span class="o">&lt;</span> <span class="s1">&#39;3&#39;</span><span class="p">:</span>
            <span class="c1">#print(&#39;WARNING: InterpolatedUnivariateSpline may have different behavior in python2!&#39;)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">interpolator</span> <span class="o">=</span> <span class="n">InterpolatedUnivariateSpline</span><span class="p">(</span><span class="n">wave</span><span class="p">,</span> <span class="n">sres</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">ext</span> <span class="o">=</span> <span class="n">interp_ext</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">interpolator</span> <span class="o">=</span> <span class="n">InterpolatedUnivariateSpline</span><span class="p">(</span><span class="n">wave</span><span class="p">,</span> <span class="n">sres</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">ext</span> <span class="o">=</span> <span class="n">interp_ext</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log10</span> <span class="o">=</span> <span class="n">log10</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cnst</span> <span class="o">=</span> <span class="n">constants</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="n">astropy</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s1">&#39;km/s&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">value</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">dv</span> <span class="o">=</span> <span class="n">spectrum_velocity_scale</span><span class="p">(</span><span class="n">wave</span><span class="p">)</span> <span class="k">if</span> <span class="n">log10</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dw</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">log10</span> <span class="k">else</span> <span class="n">wave</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">wave</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># No resolution matching calculated yet</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_sig</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sig_pd</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sig_mask</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sig_vo</span> <span class="o">=</span> <span class="kc">None</span>


    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Interpolate the spectral resolution at wavelength *w*.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">interpolator</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">_finalize_GaussianKernelDifference</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sig2_pd</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given the calculated :math:`\sigma^2_{p,d}`, calculate and save</span>
<span class="sd">        the attributes :attr:`sig_pd` and :attr:`sig_mask`.  See</span>
<span class="sd">        :func:`GaussianKernelDifference`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">indx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">sig2_pd</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">))</span>
        <span class="n">nindx</span> <span class="o">=</span> <span class="n">where_not</span><span class="p">(</span><span class="n">indx</span><span class="p">,</span> <span class="n">sig2_pd</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sig_pd</span> <span class="o">=</span> <span class="n">sig2_pd</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sig_pd</span><span class="p">[</span><span class="n">nindx</span><span class="p">]</span> <span class="o">=</span> <span class="n">sig2_pd</span><span class="p">[</span><span class="n">nindx</span><span class="p">]</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">sig2_pd</span><span class="p">[</span><span class="n">nindx</span><span class="p">]))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sig_pd</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sig_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sig_pd</span> <span class="o">&lt;</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">min_sig</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">_convert_vd2pd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sig2_vd</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert from :math:`\sigma^2_{v,d}` to :math:`\sigma^2_{p,d}`.</span>
<span class="sd">        See :func:`GaussianKernelDifference`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">sig2_vd</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dv</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log10</span> <span class="k">else</span> \
               <span class="n">sig2_vd</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dw</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">wave</span><span class="p">())</span>


    <span class="k">def</span> <span class="nf">_convert_pd2vd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sig2_pd</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert from :math:`\sigma^2_{p,d}` to :math:`\sigma^2_{v,d}`.</span>
<span class="sd">        See :func:`GaussianKernelDifference`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">sig2_pd</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dv</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log10</span> <span class="k">else</span> \
               <span class="n">sig2_pd</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dw</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">wave</span><span class="p">())</span>


<div class="viewcode-block" id="spectral_resolution.wave"><a class="viewcode-back" href="../firefly_instrument.html#firefly_instrument.spectral_resolution.wave">[docs]</a>    <span class="k">def</span> <span class="nf">wave</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the wavelength vector; held by :attr:`interpolator`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">interpolator</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>


<div class="viewcode-block" id="spectral_resolution.sres"><a class="viewcode-back" href="../firefly_instrument.html#firefly_instrument.spectral_resolution.sres">[docs]</a>    <span class="k">def</span> <span class="nf">sres</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the resolution vector; held by :attr:`interpolator`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">interpolator</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span></div>


<div class="viewcode-block" id="spectral_resolution.match"><a class="viewcode-back" href="../firefly_instrument.html#firefly_instrument.spectral_resolution.match">[docs]</a>    <span class="k">def</span> <span class="nf">match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_sres</span><span class="p">,</span> <span class="n">no_offset</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">min_sig_pix</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Currently only an alias for :func:`GaussianKernelDifference`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">GaussianKernelDifference</span><span class="p">(</span><span class="n">new_sres</span><span class="p">,</span> <span class="n">no_offset</span><span class="o">=</span><span class="n">no_offset</span><span class="p">,</span> <span class="n">min_sig_pix</span><span class="o">=</span><span class="n">min_sig_pix</span><span class="p">)</span></div>


<div class="viewcode-block" id="spectral_resolution.GaussianKernelDifference"><a class="viewcode-back" href="../firefly_instrument.html#firefly_instrument.spectral_resolution.GaussianKernelDifference">[docs]</a>    <span class="k">def</span> <span class="nf">GaussianKernelDifference</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_sres</span><span class="p">,</span> <span class="n">no_offset</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">min_sig_pix</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine the parameters of a Gaussian kernel required to</span>
<span class="sd">        convert the resolution of this object to the resolution of a</span>
<span class="sd">        different the :class:`spectral_resolution` object, *new_sres*.</span>

<span class="sd">        The spectral resolution is defined as :math:`R =</span>
<span class="sd">        \lambda/\Delta\lambda`, where :math:`\Delta\lambda` is the FWHM</span>
<span class="sd">        of the spectral resolution element.  The standard deviation of</span>
<span class="sd">        the resolution element in angstroms is then</span>
<span class="sd">   </span>
<span class="sd">        .. math::</span>
<span class="sd">    </span>
<span class="sd">            \sigma_\lambda = \frac{\lambda}{f R}, \ \ {\rm where} \ \  f</span>
<span class="sd">            = \frac{{\rm FWHM_\lambda}}{\sigma_\lambda}.</span>

<span class="sd">        Assuming a Gaussian (in angstroms) line-spread function:</span>

<span class="sd">        .. math::</span>

<span class="sd">            \sigma^2_{\lambda,2} = \sigma^2_{\lambda,1} +</span>
<span class="sd">            \sigma^2_{\lambda,d}</span>

<span class="sd">        such that</span>

<span class="sd">        .. math::</span>

<span class="sd">            \sigma^2_{\lambda,d} = \left(\frac{\lambda}{f}\right)^2</span>
<span class="sd">            (R^{-2}_2 - R^{-2}_1)</span>

<span class="sd">        is the defining parameter of the Gaussian kernel needed to take</span>
<span class="sd">        a spectrum of resolution :math:`R_1` to one with a resolution of</span>
<span class="sd">        :math:`R_2`.</span>

<span class="sd">        For input to :func:`convolution_variable_sigma`, the</span>
<span class="sd">        *wavelength-dependent* parameter of the Gaussian kernel is</span>
<span class="sd">        converted to pixels.  This function allows for the input spectra</span>
<span class="sd">        to be linearly sampled in angstroms or log10(angstroms).  For</span>
<span class="sd">        the former (*log10=False*), </span>

<span class="sd">        .. math::</span>

<span class="sd">            \sigma^2_{p,d} = \left(\frac{\lambda}{f\</span>
<span class="sd">            \delta\lambda}\right)^2 (R^{-2}_2 - R^{-2}_1)</span>

<span class="sd">        where :math:`\delta\lambda` is the size of the pixel in</span>
<span class="sd">        angstroms.  If the units are log10(angstrom) (*log10=True*), we</span>
<span class="sd">        approximate the velocity width of each pixel to be :math:`\delta</span>
<span class="sd">        v = c \ln(10.0) (\log\lambda[1]-\log\lambda[0])`, such that</span>
<span class="sd">    </span>
<span class="sd">        .. math::</span>

<span class="sd">            \sigma^2_{p,d} &amp;= \left(\frac{c}{ \delta v \lambda}\right)^2</span>
<span class="sd">            \sigma^2_{\lambda,d} \\ &amp;= \left(\frac{c}{ f\ \delta</span>
<span class="sd">            v}\right)^2 (R^{-2}_2 - R^{-2}_1)\ ;</span>

<span class="sd">        :math:`c` is the speed of light in km/s.</span>

<span class="sd">        The nominal use of this algorithm assumes :math:`R_1 \geq R_2`.</span>
<span class="sd">        However, in practice, :func:`convolution_variable_sigma` only</span>
<span class="sd">        uses a Gaussian kernel up to some minimum value of</span>
<span class="sd">        :math:`\epsilon_\sigma`; below this, the kernel is assumed to be</span>
<span class="sd">        a Delta function.  Therefore, as long as</span>
<span class="sd">    </span>
<span class="sd">        .. math::</span>
<span class="sd">    </span>
<span class="sd">            \sigma_{p,d} \equiv \sigma^2_{p,d}/\sqrt{|\sigma^2_{p,d}|}</span>
<span class="sd">            \geq -\epsilon_\sigma\ ,</span>
<span class="sd">        </span>
<span class="sd">        the behavior of :func:`convolution_variable_sigma` should not be</span>
<span class="sd">        affected.</span>
<span class="sd">    </span>
<span class="sd">        Even so, there may be spectral regions that do not have</span>
<span class="sd">        :math:`\sigma_{p,d} \geq -\epsilon_\sigma`; for such spectral</span>
<span class="sd">        regions there are three choices:</span>

<span class="sd">            (**Option 1**) trim the spectral range to only those</span>
<span class="sd">            spectral regions where the existing resolution is better</span>
<span class="sd">            than the target resolution,</span>
<span class="sd">        </span>
<span class="sd">            (**Option 2**) match the existing resolution to the target</span>
<span class="sd">            resolution up to some constant offset that must be accounted</span>
<span class="sd">            for in subsequent analyses, or</span>

<span class="sd">            (**Option 3**) allow for a wavelength dependent difference</span>
<span class="sd">            in the spectral resolution that must be accounted for in</span>
<span class="sd">            subsequent analyses.</span>

<span class="sd">        The choice of either Option 1 or 2 is selected by setting</span>
<span class="sd">        *no_offset* to, respectively, True or False; Option 1 is the</span>
<span class="sd">        default behavior.  Currently, Option 3 is not allowed.</span>

<span class="sd">        For Option 1, pixels with :math:`\sigma_{p,d} &lt;</span>
<span class="sd">        -\epsilon_\sigma` are masked (*sigma_mask = 1*); however, the</span>
<span class="sd">        returned values of :math:`\sigma_{p,d}` are left unchanged.</span>

<span class="sd">        For Option 2, we define</span>

<span class="sd">        .. math::</span>

<span class="sd">            \sigma^2_{v,o} = -{\rm min}(\sigma^2_{v,d}) - {\rm</span>
<span class="sd">            max}(\epsilon_\sigma \delta v)^2</span>

<span class="sd">        where :math:`\delta v` is constant for the logarithmically</span>
<span class="sd">        binned spectrum and is wavelength dependent for the linearly</span>
<span class="sd">        binned spectra; in the latter case, the velocity step is</span>
<span class="sd">        determined for each pixel::</span>

<span class="sd">            _wave = self.wave()</span>
<span class="sd">            dv = self.c * (2.0*(_wave[1:] - _wave[0:-1]) / (_wave[1:] + _wave[0:-1]))</span>

<span class="sd">        If :math:`\sigma^2_{v,o} &gt; 0.0`, it must be that :math:`{\rm</span>
<span class="sd">        min}(\sigma^2_{v,d}) &lt; -{\rm max}(\epsilon_\sigma \delta v)^2`,</span>
<span class="sd">        such that an offset should be applied.  In that case, the</span>
<span class="sd">        returned kernel parameters are</span>

<span class="sd">        .. math::</span>

<span class="sd">            \sigma^\prime_{v,d} = \sqrt{\sigma^2_{v,d} +</span>
<span class="sd">            \sigma^2_{v,o}}\ .</span>

<span class="sd">        with the units converted to pixels using the equations above, no</span>
<span class="sd">        pixels are masked, and :math:`\sqrt{\sigma^2_{v,o}}` is returned</span>
<span class="sd">        for the offset.  Otherwise, the offset is set to 0.</span>

<span class="sd">        .. todo::</span>

<span class="sd">            Allow to check cases when the convolution kernel is</span>
<span class="sd">            indpendent of wavelength such that the convolution can be</span>
<span class="sd">            sped up by performing the convolution using an FFT.  For</span>
<span class="sd">            example, in the case where the spectrum is logarithmically</span>
<span class="sd">            binned and both :math:`R_1` and :math:`R_2` are</span>
<span class="sd">            *independent* of wavelength, the convolution kernel is</span>
<span class="sd">            independent of wavelength.</span>

<span class="sd">        Args:</span>
<span class="sd">            new_sres (:class:`spectral_resolution`): Spectral resolution</span>
<span class="sd">                to match to.</span>
<span class="sd">            no_offset (bool): (**Optional**) Force :math:`\sigma^2_{v,o}</span>
<span class="sd">                = 0` by masking regions with :math:`\sigma_{p,d} &lt;</span>
<span class="sd">                -\epsilon_\sigma`; i.e., the value of this arguments</span>
<span class="sd">                selects Option 1 (True) or Option 2 (False).</span>
<span class="sd">            min_sig_pix (float): (**Optional**) Minimum value of the</span>
<span class="sd">                standard deviation allowed before assuming the kernel is</span>
<span class="sd">                a Delta function.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Save the minimum pixel sigma to allow</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_sig</span> <span class="o">=</span> <span class="n">min_sig_pix</span>

        <span class="c1"># Interpolate the new spectral resolution vector at the wavelengths</span>
        <span class="c1"># of the input spectral resolution</span>
        <span class="n">_wave</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wave</span><span class="p">()</span>
        <span class="n">_sres</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sres</span><span class="p">()</span>
        <span class="n">interp_sres</span> <span class="o">=</span> <span class="n">new_sres</span><span class="p">(</span><span class="n">_wave</span><span class="p">)</span>

        <span class="c1"># Determine the variance (in angstroms) of Gaussian needed to match</span>
        <span class="c1"># input resolution to the new values</span>
        <span class="n">sig2_wd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">_wave</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">cnst</span><span class="o">.</span><span class="n">sig2fwhm</span><span class="p">)</span> \
                  <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">interp_sres</span><span class="p">)</span> <span class="o">-</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">_sres</span><span class="p">))</span>
        <span class="c1"># Convert to km/s</span>
        <span class="n">sig2_vd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">/</span><span class="n">_wave</span><span class="p">)</span> <span class="o">*</span> <span class="n">sig2_wd</span>

        <span class="c1"># Option 1:</span>
        <span class="k">if</span> <span class="n">no_offset</span><span class="p">:</span>
            <span class="c1"># Convert the variance to pixel coordinates</span>
            <span class="n">sig2_pd</span> <span class="o">=</span> <span class="n">sig2_vd</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dv</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log10</span> <span class="k">else</span> \
                      <span class="n">sig2_wd</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dw</span><span class="p">)</span>
            <span class="c1"># No offset applied</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sig_vo</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="c1"># Option 2:</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Calculate the velocity step of each pixel</span>
            <span class="n">dv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="o">*</span> <span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="p">(</span><span class="n">_wave</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">_wave</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="n">_wave</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">_wave</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
            <span class="c1"># Get the needed *velocity* offset (this is the square)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sig_vo</span> <span class="o">=</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">sig2_vd</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">min_sig</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">dv</span><span class="p">))</span>
            <span class="c1"># Apply it if it&#39;s larger than 0</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sig_vo</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">sig2_vd</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sig_vo</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sig_vo</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sig_vo</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sig_vo</span> <span class="o">=</span> <span class="mf">0.0</span>

            <span class="c1"># Convert the variance to pixel coordinates</span>
            <span class="n">sig2_pd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert_vd2pd</span><span class="p">(</span><span class="n">sig2_vd</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_finalize_GaussianKernelDifference</span><span class="p">(</span><span class="n">sig2_pd</span><span class="p">)</span></div>


<span class="c1">#    def ZeroGaussianKernelDifference(self, min_sig_pix=0.0):</span>
<span class="c1">#        self.min_sig = min_sig_pix</span>
<span class="c1">#        sig2_pd = np.zeros(self.wave().shape, dtype=np.float64)</span>
<span class="c1">#        self._finalize_GaussianKernelDifference(sig2_pd)</span>


<div class="viewcode-block" id="spectral_resolution.offset_GaussianKernelDifference"><a class="viewcode-back" href="../firefly_instrument.html#firefly_instrument.spectral_resolution.offset_GaussianKernelDifference">[docs]</a>    <span class="k">def</span> <span class="nf">offset_GaussianKernelDifference</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">offset</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If the properties required to match the resolution of one</span>
<span class="sd">        spectrum to another has already been calculated (see</span>
<span class="sd">        :func:`GaussianKernelDifference`), this allows for one to apply</span>
<span class="sd">        an additional offset.  The additional offset **must** be in km/s</span>
<span class="sd">        (not pixels).</span>

<span class="sd">        The offset is applied in quadrature; however, the offset can be</span>
<span class="sd">        negative such that one can reduce :attr:`sig_pd`.  Once</span>
<span class="sd">        converted to km/s, the offset is applied by calculating:</span>

<span class="sd">        .. math::</span>
<span class="sd">        </span>
<span class="sd">            \sigma^{\prime\ 2}_{v,d} = \sigma^{2}_{v,d} +</span>
<span class="sd">            \sigma_{off}|\sigma_{off}|\ .</span>

<span class="sd">        :attr:`sig_vo` is adjusted in the same way, and the change in</span>
<span class="sd">        :math:`\sigma^{\prime\ 2}_{v,d}` is then propagated to</span>
<span class="sd">        :attr:`sig_pd` and :attr:`sig_mask`.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            offset (float): Value of the standard deviation in km/s to</span>
<span class="sd">                add in quadrature to a previously calculated</span>
<span class="sd">                :attr:`sig_pd`.</span>
<span class="sd">        </span>
<span class="sd">        Raises:</span>
<span class="sd">            ValueError: Raised if the kernel properties have not yet</span>
<span class="sd">                been defined.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="kc">None</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">min_sig</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sig_pd</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sig_mask</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sig_vo</span><span class="p">]:</span>
<span class="c1">#            print(&#39;WARNING: No kernel difference yet defined.  Assuming 0.&#39;)</span>
<span class="c1">#            self.ZeroGaussianKernelDifference()</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;No kernel defined yet.  Run GaussianKernelDifference first.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span><span class="mf">0.0</span><span class="p">):</span>
            <span class="k">return</span>
        <span class="n">off2</span> <span class="o">=</span> <span class="n">offset</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span>
        <span class="n">sig2_vo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sig_vo</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sig_vo</span><span class="p">)</span> <span class="o">+</span> <span class="n">off2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sig_vo</span> <span class="o">=</span> <span class="mf">0.0</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">sig2_vo</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span> \
                          <span class="k">else</span> <span class="n">sig2_vo</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">sig2_vo</span><span class="p">))</span>
        <span class="n">sig2_vd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert_pd2vd</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sig_pd</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">sig_pd</span><span class="p">))</span> <span class="o">+</span> <span class="n">off2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_finalize_GaussianKernelDifference</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_convert_vd2pd</span><span class="p">(</span><span class="n">sig2_vd</span><span class="p">))</span></div>


<div class="viewcode-block" id="spectral_resolution.adjusted_resolution"><a class="viewcode-back" href="../firefly_instrument.html#firefly_instrument.spectral_resolution.adjusted_resolution">[docs]</a>    <span class="k">def</span> <span class="nf">adjusted_resolution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Return the resolution that should result from applying</span>
<span class="sd">        :func:`convolution_variable_sigma` to the spectrum associated</span>
<span class="sd">        with this spectral resolution object using :attr:`sigma_pd`.</span>
<span class="sd">        I.e., calculate:</span>

<span class="sd">        .. math::</span>

<span class="sd">            R_2 = \left[ \left(\frac{f}{c}\right)^2 \sigma^2_{v,d} +</span>
<span class="sd">            R^{-2}_1\right]^{-1/2}\ . </span>

<span class="sd">        Args:</span>
<span class="sd">            indx (tuple): (**Optional**) Selection tuple used to return</span>
<span class="sd">                a subset of the full resolution vector.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: The (full or selected) vector with the</span>
<span class="sd">            adjusted resolution.</span>

<span class="sd">        .. todo::</span>
<span class="sd">            Allow to reset the resolution of this object to the adjusted</span>
<span class="sd">            resolution and reset the kernel variables to None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">indx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cnst</span><span class="o">.</span><span class="n">sig2fwhm</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">)</span> \
                                   <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert_pd2vd</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sig_pd</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sig_pd</span><span class="p">))</span> \
                                   <span class="o">+</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sres</span><span class="p">())</span> <span class="p">)</span>

        <span class="k">return</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cnst</span><span class="o">.</span><span class="n">sig2fwhm</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">)</span> \
                            <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_convert_pd2vd</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sig_pd</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sig_pd</span><span class="p">)))[</span><span class="n">indx</span><span class="p">]</span> \
                               <span class="o">+</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sres</span><span class="p">()[</span><span class="n">indx</span><span class="p">])</span> <span class="p">)</span></div></div>


<div class="viewcode-block" id="match_spectral_resolution"><a class="viewcode-back" href="../firefly_instrument.html#firefly_instrument.match_spectral_resolution">[docs]</a><span class="k">def</span> <span class="nf">match_spectral_resolution</span><span class="p">(</span><span class="n">wave</span><span class="p">,</span> <span class="n">flux</span><span class="p">,</span> <span class="n">sres</span><span class="p">,</span> <span class="n">new_sres_wave</span><span class="p">,</span> <span class="n">new_sres</span><span class="p">,</span> <span class="n">ivar</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                              <span class="n">min_sig_pix</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">no_offset</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">variable_offset</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">log10</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                              <span class="n">new_log10</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Adjust the existing spectral resolution of a spectrum to a **lower**</span>
<span class="sd">    resolution as best as possible.  The primary functionality is in</span>
<span class="sd">    :class:`spectral_resolution`, which determines the Gaussian kernel</span>
<span class="sd">    parameters needed to match the resolution, and</span>
<span class="sd">    :func:`convolve_variable_sigma`, which actually performs the</span>
<span class="sd">    convolution to match the resolution.</span>

<span class="sd">    In particular, see</span>
<span class="sd">    :func:`spectral_resolution.GaussianKernelDifference` for a</span>
<span class="sd">    description of how the kernel parameters are determined and how</span>
<span class="sd">    regions where the target resolution is **higher** than the existing</span>
<span class="sd">    resolution.  In this case, one of the options is to adopt an offset</span>
<span class="sd">    of the resolution (in km/s) that could be corrected for in</span>
<span class="sd">    subsequent analysis.  In this case, setting *variable_offset* to</span>
<span class="sd">    True allows the offset to be different for all input spectra.  If</span>
<span class="sd">    one expects to combine the spectra, the default behavior should be</span>
<span class="sd">    used, forcing all the spectra to have a constant offset.</span>

<span class="sd">    Args:</span>
<span class="sd">        wave (np.ndarray): A 1D or 2D (:math:`N_{\rm spec}\times</span>
<span class="sd">            N_{\rm pix}`) array with the wavelength in angstroms for a</span>
<span class="sd">            set of spectra.  The sampling may be either in linear steps</span>
<span class="sd">            of wavelength or :math:`\log_{10}` steps, as set using</span>
<span class="sd">            *log10*.</span>
<span class="sd">        flux (np.ndarray): A 1D or 2D (:math:`N_{\rm spec}\times</span>
<span class="sd">            N_{\rm pix}`) array with the flux sampled at the provided</span>
<span class="sd">            wavelengths.</span>
<span class="sd">        sres (np.ndarray): A 1D or 2D (:math:`N_{\rm spec}\times</span>
<span class="sd">            N_{\rm pix}`) array with the spectral resolution, :math:`R`,</span>
<span class="sd">            at the provided wavelengths.</span>
<span class="sd">        new_sres_wave (np.ndarray): A 1D vector with the wavelength</span>
<span class="sd">            in angstroms at which the new resolution of the input</span>
<span class="sd">            spectra has been sampled.  The sampling may be either in</span>
<span class="sd">            linear steps of wavelength or :math:`\log_{10}` steps, as</span>
<span class="sd">            set using *new_log10*.</span>
<span class="sd">        new_sres (np.ndarray): A 1D vector with the new resolution</span>
<span class="sd">            for the input spectra.</span>
<span class="sd">        ivar (np.ndarray): (**Optional**) A 1D or 2D (:math:`N_{\rm</span>
<span class="sd">            spec}\times N_{\rm pix}`) array with the inverse variance of</span>
<span class="sd">            the flux sampled at the provided wavelengths.  This vector</span>
<span class="sd">            is used to estimate the noise in the resolution-matched</span>
<span class="sd">            spectra.</span>

<span class="sd">            .. warning::</span>
<span class="sd">                The accuracy of the errors still remain untested!</span>
<span class="sd">            </span>
<span class="sd">        mask (np.ndarray): (**Optional**) A 1D or 2D (:math:`N_{\rm</span>
<span class="sd">            spec}\times N_{\rm pix}`) array with a *uint* mask for the</span>
<span class="sd">            flux sampled at the provided wavelengths.</span>
<span class="sd">        no_offset (bool): (**Optional**) Force :math:`\sigma^2_{v,o} =</span>
<span class="sd">            0` by masking regions with :math:`\sigma_{p,d} &lt;</span>
<span class="sd">            -\epsilon_\sigma`; i.e., the value of this arguments selects</span>
<span class="sd">            Option 1 (True) or Option 2 (False).  See</span>
<span class="sd">            :func:`spectral_resolution.GaussianKernelDifference`.</span>
<span class="sd">        min_sig_pix (float): (**Optional**) Minimum value of the</span>
<span class="sd">            standard deviation in pixels allowed before assuming the</span>
<span class="sd">            kernel is a Delta function.</span>
<span class="sd">        variable_offset (bool): (**Optional**) Flag to allow the offset</span>
<span class="sd">            applied to each spectrum (when the input contains more than</span>
<span class="sd">            one spectraum) to be tailored to each spectrum.  Otherwise</span>
<span class="sd">            (*variable_offset=False*) the offset is forced to be the</span>
<span class="sd">            same for all spectra.</span>
<span class="sd">        log10 (bool): (**Optional**) Flag that the spectrum has been</span>
<span class="sd">            binned logarithmically (base 10) in wavelength</span>
<span class="sd">        new_log10 (bool): (**Optional**) Flag that the coordinates of</span>
<span class="sd">            the new spectral resolution are  spectrum as been binned</span>
<span class="sd">            logarithmically (base 10) in wavelength.</span>

<span class="sd">    Returns: </span>
<span class="sd">        np.ndarray: Five objects are returned:</span>

<span class="sd">            - A 1D or 2D (:math:`N_{\rm spec}\times N_{\rm pix}`) array</span>
<span class="sd">              with the resolution-matched flux sampled at the input</span>
<span class="sd">              wavelengths.</span>
<span class="sd">            - A 1D or 2D (:math:`N_{\rm spec}\times N_{\rm pix}`) array</span>
<span class="sd">              with the spectral resolution, :math:`R`, of the</span>
<span class="sd">              resolution-matched spectra at the provided wavelengths.</span>
<span class="sd">            - A 1D vector with any constant offset in resolution **in</span>
<span class="sd">              km/s** between the targetted value and the result.  See</span>
<span class="sd">              :func:`spectral_resolution.GaussianKernelDifference`.</span>
<span class="sd">            - A 1D or 2D (:math:`N_{\rm spec}\times N_{\rm pix}`) array</span>
<span class="sd">              with a *uint* mask for the resolution-matched flux sampled</span>
<span class="sd">              at the input wavelengths.  This is returned regardless of</span>
<span class="sd">              whether an input mask was provided.  Any pixel that had a</span>
<span class="sd">              resolution that was lower than the target resolution (up</span>
<span class="sd">              to some tolerance defined by *min_sig_pix*) is returned as</span>
<span class="sd">              masked.</span>
<span class="sd">            - A 1D or 2D (:math:`N_{\rm spec}\times N_{\rm pix}`) array</span>
<span class="sd">              with the inverse variance of the resolution-matched flux</span>
<span class="sd">              sampled at the input wavelengths.  If *ivar*</span>
<span class="sd">              is not provided, a &#39;None&#39; returned as the last element</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: Raised if:</span>

<span class="sd">            - the input *wave* array is 2D and the *sres* array is not;</span>
<span class="sd">              a 1D wavelength array is allowed for a 2D *sres* array but</span>
<span class="sd">              not vice versa</span>

<span class="sd">            - the number of spectral pixels in *wave*, *flux*, and</span>
<span class="sd">              *sres* is not the same</span>

<span class="sd">            - the shape of the *flux*, *mask* (if provided), and *ivar*</span>
<span class="sd">              (if provided) are not the same</span>

<span class="sd">            - the shape of the *new_sres_wave* and *new_sres* arrays</span>
<span class="sd">              are not the same and/or not 1D</span>

<span class="sd">    .. todo::</span>

<span class="sd">        - Add interp_ext != &#39;extrapolate&#39; option?</span>
<span class="sd">        - Better way to use warnings?</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check the dimensionality of wave and sres</span>
    <span class="n">wave_matrix</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">wave</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
    <span class="n">sres_matrix</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sres</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
    <span class="k">if</span> <span class="n">wave_matrix</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">sres_matrix</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;If input wavelength array is 2D, the spectral resolution array must&#39;</span> \
                         <span class="s1">&#39; also be 2D&#39;</span><span class="p">)</span>

    <span class="c1"># Check the shapes</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">wave_matrix</span> <span class="o">==</span> <span class="n">sres_matrix</span> <span class="ow">and</span> <span class="n">wave</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">sres</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="ow">or</span> \
       <span class="p">(</span><span class="ow">not</span> <span class="n">wave_matrix</span> <span class="ow">and</span> <span class="n">sres_matrix</span> <span class="ow">and</span> <span class="n">wave</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">sres</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Input spectral resolution and coordinate arrays must have the same&#39;</span> \
                         <span class="s1">&#39; number of spectral channels!&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">wave_matrix</span> <span class="ow">and</span> <span class="n">wave</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">flux</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="ow">or</span> \
       <span class="p">(</span><span class="ow">not</span> <span class="n">wave_matrix</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">flux</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">wave</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">flux</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="ow">or</span> \
       <span class="p">(</span><span class="ow">not</span> <span class="n">wave_matrix</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">flux</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">wave</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">flux</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Input flux and coordinate arrays must have the same number of&#39;</span> \
                         <span class="s1">&#39; spectral channels!&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">mask</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">flux</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Input flux and mask arrays must have the same shape!&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ivar</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">ivar</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">flux</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Input flux and ivar arrays must have the same shape!&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sres</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">flux</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Shape of the spectral resolution array must be &lt;= to the flux array.&#39;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_sres_wave</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_sres</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;New spectral resolution and coordinate arrays must be 1D!&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">new_sres_wave</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">new_sres</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;New spectral resolution and coordinate arrays must have the same shape!&#39;</span><span class="p">)</span>

    <span class="c1"># Raise a warning if the new_sres vector will have to be</span>
    <span class="c1"># extrapolated for the input wavelengths</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">wave</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">new_sres_wave</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">wave</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">new_sres_wave</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Mapping to the new spectral resolution will require extrapolating the&#39;</span> \
                      <span class="s1">&#39; provided input vectors!&#39;</span><span class="p">)</span>

    <span class="c1"># Initialize some variables</span>
    <span class="n">nspec</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">flux</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">flux</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">nsres</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sres</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">sres</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">sres_matrix</span> <span class="ow">and</span> <span class="n">nspec</span> <span class="o">!=</span> <span class="n">nsres</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;For 2D matrices, number of spectral resolution vectors must match the &#39;</span> \
                         <span class="s1">&#39;number of spectra.&#39;</span><span class="p">)</span>
    <span class="n">spec_dim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">flux</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">sres_dim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sres</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">sigma_offset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nspec</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="n">new_res</span> <span class="o">=</span> <span class="n">spectral_resolution</span><span class="p">(</span><span class="n">new_sres_wave</span><span class="p">,</span> <span class="n">new_sres</span><span class="p">,</span> <span class="n">log10</span><span class="o">=</span><span class="n">new_log10</span><span class="p">)</span>

    <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">nspec</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>

    <span class="c1"># Get the kernel parameters necessary to match all spectra to the</span>
    <span class="c1"># new resolution</span>
    <span class="k">if</span> <span class="n">nsres</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">sres_dim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">spectral_resolution</span><span class="p">(</span><span class="n">wave</span><span class="p">,</span> <span class="n">sres</span><span class="p">,</span> <span class="n">log10</span><span class="o">=</span><span class="n">log10</span><span class="p">)</span>
        <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">new_res</span><span class="p">,</span> <span class="n">no_offset</span><span class="o">=</span><span class="n">no_offset</span><span class="p">,</span> <span class="n">min_sig_pix</span><span class="o">=</span><span class="n">min_sig_pix</span><span class="p">)</span>
        <span class="n">sigma_offset</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">sig_vo</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">nspec</span><span class="p">):</span>
            <span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="c1">#        pyplot.plot(wave, res[0].sig_pd)</span>
<span class="c1">#        pyplot.show()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">nsres</span><span class="p">):</span>
            <span class="n">_wave</span> <span class="o">=</span> <span class="n">wave</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span> <span class="k">if</span> <span class="n">wave_matrix</span> <span class="k">else</span> <span class="n">wave</span>
            <span class="n">_sres</span> <span class="o">=</span> <span class="n">sres</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span> <span class="k">if</span> <span class="n">sres_matrix</span> <span class="k">else</span> <span class="n">sres</span>
            <span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">spectral_resolution</span><span class="p">(</span><span class="n">_wave</span><span class="p">,</span> <span class="n">_sres</span><span class="p">,</span> <span class="n">log10</span><span class="o">=</span><span class="n">log10</span><span class="p">)</span>
            <span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">new_res</span><span class="p">,</span> <span class="n">no_offset</span><span class="o">=</span><span class="n">no_offset</span><span class="p">,</span> <span class="n">min_sig_pix</span><span class="o">=</span><span class="n">min_sig_pix</span><span class="p">)</span>
            <span class="n">sigma_offset</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">sig_vo</span>

    <span class="c1"># Force all the offsets to be the same, if requested</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">no_offset</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">variable_offset</span><span class="p">:</span>
        <span class="n">common_offset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">sigma_offset</span><span class="p">)</span>
        <span class="n">offset_diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">common_offset</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">sigma_offset</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">r</span><span class="p">,</span> <span class="n">o</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">res</span><span class="p">,</span><span class="n">offset_diff</span><span class="p">):</span>
            <span class="n">r</span><span class="o">.</span><span class="n">offset_GaussianKernelDifference</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>

    <span class="c1"># Perform the convolutions</span>
    <span class="n">out_flux</span> <span class="o">=</span> <span class="n">flux</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">out_ivar</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">ivar</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span><span class="n">ivar</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
    <span class="n">noise</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">ivar</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="n">out_ivar</span><span class="p">)</span>
    <span class="n">out_sres</span> <span class="o">=</span> <span class="n">sres</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">flux</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint</span><span class="p">)</span>
    <span class="n">out_mask</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">nspec</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">spec_dim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">indx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">sig_pd</span> <span class="o">&gt;</span> <span class="n">min_sig_pix</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ivar</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">out_flux</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="n">convolution_variable_sigma</span><span class="p">(</span><span class="n">flux</span><span class="p">[</span><span class="n">indx</span><span class="p">],</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">sig_pd</span><span class="p">[</span><span class="n">indx</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">out_flux</span><span class="p">[</span><span class="n">indx</span><span class="p">],</span> <span class="n">out_ivar</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span> \
                    <span class="o">=</span> <span class="n">convolution_variable_sigma</span><span class="p">(</span><span class="n">flux</span><span class="p">[</span><span class="n">indx</span><span class="p">],</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">sig_pd</span><span class="p">[</span><span class="n">indx</span><span class="p">],</span>
                                                 <span class="n">ye</span><span class="o">=</span><span class="kc">None</span> <span class="k">if</span> <span class="n">ivar</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">noise</span><span class="p">[</span><span class="n">indx</span><span class="p">])</span>
        <span class="n">out_sres</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">adjusted_resolution</span><span class="p">(</span><span class="n">indx</span><span class="o">=</span><span class="n">indx</span><span class="p">)</span>
        <span class="n">out_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">sig_mask</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">mask</span> <span class="o">==</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">nspec</span><span class="p">):</span>
            <span class="c1">#print(&#39;Matching resolution ... {0}/{1}&#39;.format(i+1,nspec), end=&#39;\r&#39;)</span>
            <span class="n">indx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">sig_pd</span> <span class="o">&gt;</span> <span class="n">min_sig_pix</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ivar</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">out_flux</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="n">convolution_variable_sigma</span><span class="p">(</span><span class="n">flux</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">indx</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span>
                                                              <span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">sig_pd</span><span class="p">[</span><span class="n">indx</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">out_flux</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">indx</span><span class="p">],</span> <span class="n">out_ivar</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">indx</span><span class="p">]</span> \
                        <span class="o">=</span> <span class="n">convolution_variable_sigma</span><span class="p">(</span><span class="n">flux</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">indx</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">sig_pd</span><span class="p">[</span><span class="n">indx</span><span class="p">],</span>
                                                <span class="n">ye</span><span class="o">=</span><span class="kc">None</span> <span class="k">if</span> <span class="n">ivar</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">noise</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">indx</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
<span class="c1">#           out_flux[i,indx] = convolution_variable_sigma(flux[i,indx].ravel(), res[i].sig_pd[indx])</span>
            <span class="n">out_mask</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">sig_mask</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> \
                                        <span class="o">|</span> <span class="p">(</span><span class="n">mask</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">nsres</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">out_sres</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">adjusted_resolution</span><span class="p">(</span><span class="n">indx</span><span class="o">=</span><span class="n">indx</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="k">elif</span> <span class="n">nsres</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">out_sres</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">adjusted_resolution</span><span class="p">(</span><span class="n">indx</span><span class="o">=</span><span class="n">indx</span><span class="p">)</span>
        <span class="c1">#print(&#39;Matching resolution ... DONE         &#39;)</span>

    <span class="c1"># TODO: Add this functionality from the IDL version?</span>
    <span class="c1">#</span>
    <span class="c1"># Finally, the code masks a number of pixels at the beginning and</span>
    <span class="c1"># end of the spectra to remove regions affected by errors in the</span>
    <span class="c1"># convolution due to the censoring of the data.  The number of</span>
    <span class="c1"># pixels is the FWHM of the largest Gaussian applied in the</span>
    <span class="c1"># convolution: ceil(sig2fwhm*max(diff_sig_w)/dw).  This is currently</span>
    <span class="c1"># hard-wired and should be tested.</span>

    <span class="k">if</span> <span class="n">ivar</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">out_ivar</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="n">out_ivar</span><span class="p">)</span>
        <span class="c1"># When returning out_ivar, convert it to a normal array</span>
        <span class="k">return</span> <span class="n">out_flux</span><span class="p">,</span> <span class="n">out_sres</span><span class="p">,</span> <span class="n">sigma_offset</span><span class="p">,</span> <span class="n">out_mask</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">out_ivar</span><span class="p">)</span>
    <span class="c1">#return out_flux, out_sres, sigma_offset, out_mask, None</span>
    <span class="k">return</span> <span class="n">out_flux</span><span class="p">,</span> <span class="n">out_sres</span><span class="p">,</span> <span class="n">sigma_offset</span><span class="p">,</span> <span class="n">out_mask</span></div>

<span class="c1">#def log_rebin(lamRange, spec, oversample=None, velscale=None, flux=False, log10=False,</span>
<span class="c1">#              newRange=None, wave_in_ang=False, unobs=0.0):</span>
<span class="c1">#    &quot;&quot;&quot;</span>
<span class="c1">#    .. note::</span>
<span class="c1">#     </span>
<span class="c1">#        Copyright (C) 2001-2014, Michele Cappellari</span>
<span class="c1">#        E-mail: cappellari_at_astro.ox.ac.uk</span>
<span class="c1">#     </span>
<span class="c1">#        This software is provided as is without any warranty whatsoever.</span>
<span class="c1">#        Permission to use, for non-commercial purposes is granted.</span>
<span class="c1">#        Permission to modify for personal or internal use is granted,</span>
<span class="c1">#        provided this copyright and disclaimer are included unchanged at</span>
<span class="c1">#        the beginning of the file. All other rights are reserved.</span>
<span class="c1">#</span>
<span class="c1">#    Logarithmically rebin a spectrum, while rigorously conserving the</span>
<span class="c1">#    flux.  Basically the photons in the spectrum are simply</span>
<span class="c1">#    ridistributed according to a new grid of pixels, with non-uniform</span>
<span class="c1">#    size in the spectral direction.</span>
<span class="c1">#    </span>
<span class="c1">#    This routine makes the `standard&#39; zero-order assumption that the</span>
<span class="c1">#    spectrum is *constant* within each pixels. It is possible to perform</span>
<span class="c1">#    log-rebinning by assuming the spectrum is represented by a</span>
<span class="c1">#    piece-wise polynomial of higer degree, while still obtaining a</span>
<span class="c1">#    uniquely defined linear problem, but this reduces to a deconvolution</span>
<span class="c1">#    and amplifies noise.</span>
<span class="c1">#</span>
<span class="c1">#    .. warning::</span>
<span class="c1">#</span>
<span class="c1">#        This assumption can be poor for sharp features in the spectrum.</span>
<span class="c1">#        Beware if resampling spectra with strong, marginally sampled</span>
<span class="c1">#        features!</span>
<span class="c1">#    </span>
<span class="c1">#    This same routine can be used to compute approximate errors of the</span>
<span class="c1">#    log-rebinned spectrum. To do this type the command</span>
<span class="c1">#    </span>
<span class="c1">#    &gt;&gt;&gt; err2New, logLam, velscale = log_rebin(lamRange, np.square(err))</span>
<span class="c1">#    </span>
<span class="c1">#    and the desired errors will be given by np.sqrt(err2New).</span>
<span class="c1">#    </span>
<span class="c1">#    .. warning::</span>
<span class="c1">#    </span>
<span class="c1">#        This rebinning of the error-spectrum is very *approximate* as it</span>
<span class="c1">#        does not consider the correlation introduced by the rebinning!</span>
<span class="c1">#</span>
<span class="c1">#    Args:</span>
<span class="c1">#</span>
<span class="c1">#        lamRange (np.ndarray): two elements vector containing the</span>
<span class="c1">#            central wavelength of the first and last pixels in the</span>
<span class="c1">#            spectrum, which is assumed to have constant wavelength</span>
<span class="c1">#            scale! E.g. from the values in the standard FITS keywords:</span>
<span class="c1">#            LAMRANGE = CRVAL1 + [0,CDELT1*(NAXIS1-1)].  It must be</span>
<span class="c1">#            LAMRANGE[0] &lt; LAMRANGE[1].</span>
<span class="c1">#        spec (np.ndarray): Input spectrum.</span>
<span class="c1">#        oversample (int): (**Optional**) Oversampling can be done, not</span>
<span class="c1">#            to loose spectral resolution, especally for extended</span>
<span class="c1">#            wavelength ranges and to avoid aliasing.  Default is to</span>
<span class="c1">#            provide the same number of output pixels as input.</span>
<span class="c1">#        velscale (float): (**Optional**) Velocity scale in km/s per</span>
<span class="c1">#            pixels. If this variable is not defined, then it will</span>
<span class="c1">#            contain in output the velocity scale.  If this variable is</span>
<span class="c1">#            defined by the user it will be used to set the output number</span>
<span class="c1">#            of pixels and wavelength scale.</span>
<span class="c1">#        flux (bool): (**Optional**) Set this keyword to preserve total</span>
<span class="c1">#            flux.  In this case the log rebinning changes the pixels</span>
<span class="c1">#            flux in proportion to their dLam so the following command</span>
<span class="c1">#            will show large differences beween the spectral shape before</span>
<span class="c1">#            and after :func:`log_rebin`::</span>
<span class="c1">#     </span>
<span class="c1">#                # Plot log-rebinned spectrum</span>
<span class="c1">#                pyplot.plot(exp(logLam), specNew)</span>
<span class="c1">#                pyplot.plot(np.arange(lamRange[0],lamRange[1],spec.size), spec, &#39;g&#39;)</span>
<span class="c1">#                pyplot.show()</span>
<span class="c1">#     </span>
<span class="c1">#            By default, when this keyword is *not* set, the above two</span>
<span class="c1">#            lines produce two spectra that almost perfectly overlap each</span>
<span class="c1">#            other.</span>
<span class="c1">#        log10 (bool): (**Optional**) Flag that the spectrum should be</span>
<span class="c1">#            binned in units of base-10 log wavelength, instead of</span>
<span class="c1">#            natural log</span>
<span class="c1">#        newRange (np.ndarray): (**Optional**) Force the spectrum to</span>
<span class="c1">#            be sampled to a new spectral range (lamRange is the</span>
<span class="c1">#            *existing* spectral range).</span>
<span class="c1">#        wave_in_ang (bool): (**Optional**) Return the wavelength</span>
<span class="c1">#            coordinates in angstroms, not log(angstroms)</span>
<span class="c1">#        unobs (float): (**Optional**) Default value for unobserved</span>
<span class="c1">#            spectral regions.</span>
<span class="c1">#</span>
<span class="c1">#    Returns:</span>
<span class="c1">#        np.ndarray, float: Returns three variables: logarithmically</span>
<span class="c1">#        rebinned spectrum, the log of the wavelength at the geometric</span>
<span class="c1">#        center of each pixel, and the velocity scale of each pixel in</span>
<span class="c1">#        km/s.</span>
<span class="c1">#        </span>
<span class="c1">#    Raises:</span>
<span class="c1">#        ValueError: Raised if the input spectrum is not a</span>
<span class="c1">#            one-dimensional np.ndarray.</span>
<span class="c1">#        </span>
<span class="c1">#    *Modification History*:</span>
<span class="c1">#        | **V1.0.0**: Using interpolation. Michele Cappellari, Leiden,</span>
<span class="c1">#            22 October 2001</span>
<span class="c1">#        | **V2.0.0**: Analytic flux conservation. MC, Potsdam, 15 June</span>
<span class="c1">#            2003</span>
<span class="c1">#        | **V2.1.0**: Allow a velocity scale to be specified by the</span>
<span class="c1">#            user.  MC, Leiden, 2 August 2003</span>
<span class="c1">#        | **V2.2.0**: Output the optional logarithmically spaced</span>
<span class="c1">#            wavelength at the geometric mean of the wavelength at the</span>
<span class="c1">#            border of each pixel.  Thanks to Jesus Falcon-Barroso. MC,</span>
<span class="c1">#            Leiden, 5 November 2003</span>
<span class="c1">#        | **V2.2.1**: Verify that lamRange[0] &lt; lamRange[1].  MC,</span>
<span class="c1">#            Vicenza, 29 December 2004</span>
<span class="c1">#        | **V2.2.2**: Modified the documentation after feedback from</span>
<span class="c1">#            James Price.  MC, Oxford, 21 October 2010</span>
<span class="c1">#        | **V2.3.0**: By default now preserve the shape of the spectrum,</span>
<span class="c1">#            not the total flux. This seems what most users expect from</span>
<span class="c1">#            the procedure.  Set the keyword /FLUX to preserve flux like</span>
<span class="c1">#            in previous version.  MC, Oxford, 30 November 2011</span>
<span class="c1">#        | **V3.0.0**: Translated from IDL into Python. MC, Santiago, 23</span>
<span class="c1">#            November 2013</span>
<span class="c1">#        | **V3.1.0**: Fully vectorized log_rebin. Typical speed up by</span>
<span class="c1">#            two orders of magnitude.  MC, Oxford, 4 March 2014</span>
<span class="c1">#        | **05 Jun 2015**: (K. Westfall, KBW) Pulled from ppxf_util.py.</span>
<span class="c1">#            Conform to mangadap documentation standard.  Transcribe</span>
<span class="c1">#            edits made to IDL version that provides for the log10 and</span>
<span class="c1">#            newRange arguments.  Add option to return wavelength in</span>
<span class="c1">#            angstroms, not log(angstroms).  Break out determination of</span>
<span class="c1">#            input and output spectrum pixel coordinates to a new</span>
<span class="c1">#            function, :func:`log_rebin_pix`.  Added default value for</span>
<span class="c1">#            unobserved pixels.  Default behavior unchanged.</span>
<span class="c1">#</span>
<span class="c1">#    .. todo::</span>
<span class="c1">#</span>
<span class="c1">#        - Allow to resample an already geometrically binned spectrum</span>
<span class="c1">#    </span>
<span class="c1">#    &quot;&quot;&quot;</span>
<span class="c1">#    lamRange = np.asarray(lamRange)</span>
<span class="c1">#</span>
<span class="c1">#    if type(spec) != np.ndarray:</span>
<span class="c1">#        raise ValueError(&#39;Input spectrum must be a np.ndarray&#39;)</span>
<span class="c1">#    s = spec.shape</span>
<span class="c1">#    if len(s) != 1:</span>
<span class="c1">#        raise ValueError(&#39;input spectrum must be a vector&#39;)</span>
<span class="c1">#    n = s[0]</span>
<span class="c1">#</span>
<span class="c1">#    # This is broken out into a separate procedure so that it can be</span>
<span class="c1">#    # called to determine the size of the rebinned spectra without</span>
<span class="c1">#    # actually doing the rebinning</span>
<span class="c1">#    dLam, m, logscale, velscale = \</span>
<span class="c1">#        log_rebin_pix(lamRange, n, oversample=oversample, velscale=velscale, log10=log10,</span>
<span class="c1">#                      newRange=newRange)</span>
<span class="c1">#    print(dLam)                        </span>
<span class="c1">#    print(m)</span>
<span class="c1">#    print(logscale)</span>
<span class="c1">#    print(velscale)</span>
<span class="c1">#</span>
<span class="c1">#    # Get the sampling of the existing spectrum</span>
<span class="c1">#    lim = lamRange/dLam + [-0.5, 0.5]           # All in units of dLam</span>
<span class="c1">#    borders = np.linspace(*lim, num=n+1)     # Linearly sampled pixels</span>
<span class="c1">#</span>
<span class="c1">#    print(borders)</span>
<span class="c1">#    print(dLam)</span>
<span class="c1">#</span>
<span class="c1">#    # Set limits to a new wavelength range</span>
<span class="c1">#    if newRange is not None:</span>
<span class="c1">#        lim = np.asarray(newRange)/dLam + [-0.5, 0.5]</span>
<span class="c1">#</span>
<span class="c1">#    # Set the limits to the (base-10 or natural) log of the wavelength</span>
<span class="c1">#    logLim = np.log(lim) if not log10 else np.log10(lim)</span>
<span class="c1">#    logLim[1] = logLim[0] + m*logscale      # Set last wavelength, based on integer # of pixels</span>
<span class="c1">#</span>
<span class="c1">#    # Geometrically spaced pixel borders for the new spectrum</span>
<span class="c1">##    newBorders = np.logspace(*logLim, num=m+1, base=(10.0 if log10 else np.exp(1)))</span>
<span class="c1">#    newBorders = np.power(10., np.linspace(*logLim, num=m+1)) if log10 else \</span>
<span class="c1">#                 np.exp(np.linspace(*logLim, num=m+1))</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1">#    print(newBorders)</span>
<span class="c1">#    print(m)</span>
<span class="c1">#    print(logscale)</span>
<span class="c1">#</span>
<span class="c1">#    # Get the new spectrum by performing an analytic integral</span>
<span class="c1">#    k = (newBorders - borders[0]).clip(0, n-1).astype(int)</span>
<span class="c1">#    specNew = np.add.reduceat(spec, k)[:-1]</span>
<span class="c1">#    specNew *= np.diff(k) &gt; 0                # fix for design flaw of reduceat()</span>
<span class="c1">#    specNew += np.diff((newBorders - borders[k])*spec[k])</span>
<span class="c1">#</span>
<span class="c1">#    # Don&#39;t conserve the flux</span>
<span class="c1">#    if not flux:</span>
<span class="c1">#        specNew /= np.diff(newBorders)</span>
<span class="c1">#</span>
<span class="c1">#    # Output log(wavelength): log of geometric mean</span>
<span class="c1">#    LamNew = np.sqrt(newBorders[1:]*newBorders[:-1])*dLam</span>
<span class="c1">#</span>
<span class="c1">#    # Set values for unobserved regions</span>
<span class="c1">#    if newRange is not None and (newRange[0] &lt; lamRange[0] or newRange[1] &gt; lamRange[1]):</span>
<span class="c1">#            specNew[ (LamNew &lt; lamRange[0]) | (LamNew &gt; lamRange[1]) ] = unobs</span>
<span class="c1">#</span>
<span class="c1">#    # Return log(wavelength), if requested</span>
<span class="c1">#    if not wave_in_ang:</span>
<span class="c1">#        LamNew = np.log10(LamNew) if log10 else np.log(LamNew)</span>
<span class="c1">#</span>
<span class="c1">#    # Return spectrum, wavelength coordinates, and pixel size in km/s</span>
<span class="c1">#    return specNew, LamNew, velscale</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1">#def log_rebin_pix(lamRange, n, oversample=None, velscale=None, log10=False, newRange=None):</span>
<span class="c1">#    &quot;&quot;&quot;</span>
<span class="c1">#    Determine the number of new pixels and their coordinate step when</span>
<span class="c1">#    rebinning a spectrum in geometrically stepped bins.  The input</span>
<span class="c1">#    spectrum must be sampled linearly in wavelength.  This is primarily</span>
<span class="c1">#    a support routine for :func:`log_rebin`.</span>
<span class="c1">#</span>
<span class="c1">#    Although breaking this out from the main :func:`log_rebin` function</span>
<span class="c1">#    leads to a few repeat calculations in that function, the use of this</span>
<span class="c1">#    function is in determine a common wavelength range for a large</span>
<span class="c1">#    number of spectra before resampling the spectra themselves.  See</span>
<span class="c1">#    :class:`mangadap.TemplateLibrary` .</span>
<span class="c1">#</span>
<span class="c1">#    Args:</span>
<span class="c1">#        lamRange (np.ndarray): two elements vector containing the</span>
<span class="c1">#            central wavelength of the first and last pixels in the</span>
<span class="c1">#            spectrum, which is assumed to have constant wavelength</span>
<span class="c1">#            scale! E.g. from the values in the standard FITS keywords:</span>
<span class="c1">#            LAMRANGE = CRVAL1 + [0,CDELT1*(NAXIS1-1)].  It must be</span>
<span class="c1">#            LAMRANGE[0] &lt; LAMRANGE[1].</span>
<span class="c1">#        n (int): Number of pixels in the original spectrum.</span>
<span class="c1">#        oversample (int): (**Optional**) Oversampling can be done, not</span>
<span class="c1">#            to loose spectral resolution, especally for extended</span>
<span class="c1">#            wavelength ranges and to avoid aliasing.  Default is to</span>
<span class="c1">#            provide the same number of output pixels as input.</span>
<span class="c1">#        velscale (float): (**Optional**) Velocity scale in km/s per</span>
<span class="c1">#            pixels. If this variable is not defined, then it will</span>
<span class="c1">#            contain in output the velocity scale.  If this variable is</span>
<span class="c1">#            defined by the user it will be used to set the output number</span>
<span class="c1">#            of pixels and wavelength scale.</span>
<span class="c1">#        log10 (bool): (**Optional**) Flag that the spectrum should be</span>
<span class="c1">#            binned in units of base-10 log wavelength, instead of</span>
<span class="c1">#            natural log</span>
<span class="c1">#        newRange (np.ndarray): (**Optional**) Force the spectrum to</span>
<span class="c1">#            be sampled to a new spectral range (lamRange is the</span>
<span class="c1">#            *existing* spectral range).</span>
<span class="c1">#</span>
<span class="c1">#    Returns:</span>
<span class="c1">#        float, int: Returns</span>
<span class="c1">#            </span>
<span class="c1">#            1. the linear wavelength step of each pixel in the input</span>
<span class="c1">#            spectrum, </span>
<span class="c1">#            2. the number of pixels for the rebinned spectrum, </span>
<span class="c1">#            3. the log-linear wavelength step for each pixel in the new</span>
<span class="c1">#            spectrum, and</span>
<span class="c1">#            4. the velocity step for each pixel in the new spectrum.</span>
<span class="c1">#</span>
<span class="c1">#    Raises:</span>
<span class="c1">#        ValueError: Raised if the input wavelength range (*lamRange* or</span>
<span class="c1">#            *newRange*) does not have two elements or is not sorted.</span>
<span class="c1">#    &quot;&quot;&quot;</span>
<span class="c1">#    lamRange = np.asarray(lamRange)</span>
<span class="c1">#    if len(lamRange) != 2:</span>
<span class="c1">#        raise ValueError(&#39;lamRange must contain two elements&#39;)</span>
<span class="c1">#    if lamRange[0] &gt;= lamRange[1]:</span>
<span class="c1">#        raise ValueError(&#39;It must be lamRange[0] &lt; lamRange[1]&#39;)</span>
<span class="c1">#</span>
<span class="c1">#    # Size of output spectrum</span>
<span class="c1">#    m = int(n) if oversample is None else int(n*oversample)</span>
<span class="c1">#</span>
<span class="c1">#    # Get the sampling of the existing spectrum</span>
<span class="c1">#    dLam = np.diff(lamRange)/(n - 1.)        # Assume constant dLam</span>
<span class="c1">#    lim = lamRange/dLam + [-0.5, 0.5]           # All in units of dLam</span>
<span class="c1">#</span>
<span class="c1">#    # Get the sampling for the new spectrum, if requested to be</span>
<span class="c1">#    # different</span>
<span class="c1">#    if newRange is not None:</span>
<span class="c1">#        newRange = np.asarray(newRange)</span>
<span class="c1">#        if len(newRange) != 2:</span>
<span class="c1">#            raise ValueError(&#39;newRange must contain two elements&#39;)</span>
<span class="c1">#        if newRange[0] &gt;= newRange[1]:</span>
<span class="c1">#            raise ValueError(&#39;It must be newRange[0] &lt; newRange[1]&#39;)</span>
<span class="c1">#        lim = newRange/dLam + [-0.5, 0.5]       # Set limits to a new wavelength range</span>
<span class="c1">#</span>
<span class="c1">#        # Adjust the length</span>
<span class="c1">#        nn = int((lamRange[1]-lamRange[0]-newRange[1]+newRange[0])/dLam)</span>
<span class="c1">#        m = m-nn if oversample is None else m-nn*oversample</span>
<span class="c1">#</span>
<span class="c1">#    # Set the limits to the (base-10 or natural) log of the wavelength</span>
<span class="c1">#    logLim = np.log(lim) if not log10 else np.log10(lim)</span>
<span class="c1">#</span>
<span class="c1">#    c = astropy.constants.c.to(&#39;km/s&#39;).value    # Speed of light in km/s (use astropy definition)</span>
<span class="c1">#</span>
<span class="c1">#    # Set the velocity scale, if velscale not provided; otherwise force</span>
<span class="c1">#    # the sampling based in the input velscale</span>
<span class="c1">#    if velscale is None:                        # Velocity scale is not set by user</span>
<span class="c1">#        velscale = np.diff(logLim)[0]/m*c    # Only for output</span>
<span class="c1">#        if log10:</span>
<span class="c1">#            velscale *= np.log(10.)          # Adjust to log base-10</span>
<span class="c1">#</span>
<span class="c1">#    logscale = velscale/c                       # dlambda/lambda = dln(lambda)</span>
<span class="c1">#    if log10:</span>
<span class="c1">#        logscale /= np.log(10.)              # Convert to dlog10(lambda)</span>
<span class="c1">#    m = int(np.diff(logLim)/logscale)        # Number of output pixels</span>
<span class="c1">#</span>
<span class="c1">#    return dLam, m, logscale, velscale</span>


<span class="k">def</span> <span class="nf">_pixel_borders</span><span class="p">(</span><span class="n">xlim</span><span class="p">,</span> <span class="n">npix</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="mf">10.0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determine the borders of the pixels in a vector.</span>

<span class="sd">    Args:</span>
<span class="sd">        xlim (np.ndarray) : (Geometric) Centers of the first and last</span>
<span class="sd">            pixel in the vector.</span>
<span class="sd">        npix (int) : Number of pixels in the vector.</span>
<span class="sd">        log (bool) : (**Optional**) The input range is (to be)</span>
<span class="sd">            logarithmically sampled.</span>
<span class="sd">        base (float) : (**Optional**) The base of the logarithmic</span>
<span class="sd">            sampling.  The default is 10.0; use np.exp(1.) for the</span>
<span class="sd">            natural logarithm.</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.ndarray, float: A vector with the (npix+1) borders of the</span>
<span class="sd">        pixels and the sampling rate.  If logarithmically binned, the</span>
<span class="sd">        sampling is the step in :math`\log x`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">log</span><span class="p">:</span>
        <span class="n">logRange</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">xlim</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>
        <span class="n">dlogx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">logRange</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">npix</span><span class="o">-</span><span class="mf">1.</span><span class="p">)</span>
        <span class="n">borders</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">logRange</span><span class="o">/</span><span class="n">dlogx</span> <span class="o">+</span> <span class="p">[</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">]),</span>
                                                   <span class="n">num</span><span class="o">=</span><span class="n">npix</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">dlogx</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">borders</span><span class="p">,</span> <span class="n">dlogx</span>
    <span class="n">dx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">xlim</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">npix</span><span class="o">-</span><span class="mf">1.</span><span class="p">)</span>
    <span class="n">borders</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">xlim</span><span class="o">/</span><span class="n">dx</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">])),</span> <span class="n">num</span><span class="o">=</span><span class="n">npix</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span>
    <span class="k">return</span> <span class="n">borders</span><span class="p">,</span> <span class="n">dx</span>


<div class="viewcode-block" id="resample_vector_npix"><a class="viewcode-back" href="../firefly_instrument.html#firefly_instrument.resample_vector_npix">[docs]</a><span class="k">def</span> <span class="nf">resample_vector_npix</span><span class="p">(</span><span class="n">outRange</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="mf">10.0</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determine the number of pixels needed to resample the vector.</span>

<span class="sd">    Args:</span>
<span class="sd">        outRange (list or np.ndarray) : Two-element array with the</span>
<span class="sd">            starting and ending x coordinate of the pixel centers to</span>
<span class="sd">            divide into pixels of a given width.  If *log* is True, this</span>
<span class="sd">            must still be the linear value of the x coordinate, not</span>
<span class="sd">            log(x)!.</span>
<span class="sd">        dx (float) : Linear or logarithmic pixel width.</span>
<span class="sd">        log (bool) : Flag that the range should be logarithmically</span>
<span class="sd">            binned.</span>
<span class="sd">        base (float) : Base for the logarithm</span>
<span class="sd">        default (int) : Default number of pixels to use.  The default is</span>
<span class="sd">            returned if either *outRange* or *dx* are not provided.</span>

<span class="sd">    Returns:</span>
<span class="sd">        int, np.ndarray: Returns two objects: The number of pixels to</span>
<span class="sd">        cover *outRange* with pixels of width *dx* and the adjusted</span>
<span class="sd">        range such that number of pixels of size dx is the exact integer.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: Raised if the range is not a two-element vector</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># If the range or sampling are not provided, the number of pixels is</span>
    <span class="c1"># already set</span>
    <span class="k">if</span> <span class="n">outRange</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">dx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">default</span><span class="p">,</span> <span class="n">outRange</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">outRange</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Output range must be a 2-element vector.&#39;</span><span class="p">)</span>

    <span class="n">_outRange</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">outRange</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">npix</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">_outRange</span><span class="p">))</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">base</span><span class="p">)</span> <span class="o">/</span> <span class="n">dx</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">log</span> <span class="k">else</span> \
                <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">_outRange</span><span class="p">)</span><span class="o">/</span><span class="n">dx</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
<span class="c1">#    _outRange = outRange</span>
    <span class="n">_outRange</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">_outRange</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">base</span><span class="p">)</span> <span class="o">+</span> <span class="n">dx</span><span class="o">*</span><span class="p">(</span><span class="n">npix</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> \
                            <span class="k">if</span> <span class="n">log</span> <span class="k">else</span> <span class="n">_outRange</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">dx</span><span class="o">*</span><span class="p">(</span><span class="n">npix</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">npix</span><span class="p">,</span> <span class="n">_outRange</span></div>


<div class="viewcode-block" id="resample_vector"><a class="viewcode-back" href="../firefly_instrument.html#firefly_instrument.resample_vector">[docs]</a><span class="k">def</span> <span class="nf">resample_vector</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">xRange</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">inLog</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">newRange</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">newpix</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">newLog</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">dx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="mf">10.0</span><span class="p">,</span> <span class="n">ext_value</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">conserve</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">flat</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Resample the provided vector to a new grid using integration.</span>

<span class="sd">    This is a generalization of the routine :func:`log_rebin` provided</span>
<span class="sd">    by Michele Cappellari in the pPXF package.</span>

<span class="sd">    Args:</span>
<span class="sd">        y (np.ndarray): Vector to resample.  Must be 1-D.</span>
<span class="sd">        xRange (array): (**Optional**) A two-element array with the</span>
<span class="sd">            starting and ending value for the coordinates of the centers</span>
<span class="sd">            of the first and last pixels in y.  If not provided, the</span>
<span class="sd">            pixel coordinates are used; i.e., xRange = [0,y.size-1].</span>
<span class="sd">        inLog (bool): (**Optional**) Flag that the input vector is</span>
<span class="sd">            logarithmically spaced within xRange.  Cannot be used if</span>
<span class="sd">            xRange is not provided!</span>
<span class="sd">        newRange (array): (**Optional**) Coordinates for the centers of</span>
<span class="sd">            the first and last pixel in the output vector.  If not</span>
<span class="sd">            provided, assumed to be the same as the input range.</span>
<span class="sd">        newpix (int): (**Optional**) Number of pixels for the output</span>
<span class="sd">            vector.  If not provided, assumed to be the same as the</span>
<span class="sd">            input vector.</span>
<span class="sd">        newLog (bool): (**Optional**) The output vector should be</span>
<span class="sd">            logarithmically binned in the x-coordinates.</span>
<span class="sd">        dx (float): (**Optional**) The sampling step for the output</span>
<span class="sd">            vector.  If *newLog* is True, this has to be the change in</span>
<span class="sd">            the logarithm of x for the output vector!  If not provided,</span>
<span class="sd">            the sampling is set by the output range (see *newRange*</span>
<span class="sd">            above) and number of pixels (see *newpix* above).</span>
<span class="sd">        base (float): (**Optional**) When logarithmically binning the</span>
<span class="sd">            output vector, use this as the base.  The default is 10.0;</span>
<span class="sd">            use np.exp(1) for natural logarithm.</span>
<span class="sd">        ext_value (float): (**Optional**) Set extrapolated values to the</span>
<span class="sd">            provided float.</span>
<span class="sd">        conserve (bool): (**Optional**) Conserve the integral of the</span>
<span class="sd">            input vector.  For example, if the input vector is a</span>
<span class="sd">            spectrum in flux units, you should conserve the flux in the</span>
<span class="sd">            resampling; if the spectrum is in units of flux density, you</span>
<span class="sd">            do not want to conserve the integral.</span>
<span class="sd">        flat (bool): (**Optional**) Assume the &#39;true&#39; y function is flat</span>
<span class="sd">            across a pixel, as is done in M. Cappellari&#39;s log_rebin</span>
<span class="sd">            routine; this is the default behavior.  If set to False, the</span>
<span class="sd">            integration follows a basic linear interpolation across the</span>
<span class="sd">            pixel.</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.ndarray: Two numpy arrays with the new x coordinates and</span>
<span class="sd">        new y values for the resampled vector.</span>
<span class="sd">    </span>
<span class="sd">    Raises:</span>
<span class="sd">        ValueError: Raised if *y* is not of type np.ndarray, if *y*</span>
<span class="sd">            is not one-dimensional, or if *xRange* is not provided and</span>
<span class="sd">            the input vector is logarithmically binned (see *inLog*</span>
<span class="sd">            above).</span>

<span class="sd">    .. todo:</span>
<span class="sd">        - Need to check if this works rebinning from log to log!</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Check operation can be performed</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Input vector must be a np.ndarray!&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Input must be a 1-D vector!&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">xRange</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">inLog</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;To specify the input vector as logarithmically binned, you must &#39;</span> \
                         <span class="s1">&#39;provided the coordinates of the first and last pixel!&#39;</span><span class="p">)</span>

    <span class="c1"># Get the pixel borders of the input vector</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">inRange</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="k">if</span> <span class="n">xRange</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">xRange</span><span class="p">)</span>
    <span class="n">inBorders</span><span class="p">,</span> <span class="n">inPscale</span> <span class="o">=</span> <span class="n">_pixel_borders</span><span class="p">(</span><span class="n">inRange</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="n">inLog</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="n">base</span><span class="p">)</span>

    <span class="c1"># Set the output range, number of pixels, pixel borders, and output</span>
    <span class="c1"># coordinate vector</span>
    <span class="n">outRange</span> <span class="o">=</span> <span class="n">inRange</span> <span class="k">if</span> <span class="n">newRange</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">newRange</span><span class="p">)</span>
    <span class="n">m</span><span class="p">,</span> <span class="n">_outRange</span> <span class="o">=</span> <span class="n">resample_vector_npix</span><span class="p">(</span><span class="n">outRange</span><span class="o">=</span><span class="n">outRange</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="n">newLog</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="n">base</span><span class="p">,</span> <span class="n">dx</span><span class="o">=</span><span class="n">dx</span><span class="p">,</span>
                                        <span class="n">default</span><span class="o">=</span><span class="p">(</span><span class="n">n</span> <span class="k">if</span> <span class="n">newpix</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">newpix</span><span class="p">))</span>
<span class="c1">#    print(outRange, m, _outRange)</span>
    <span class="n">outRange</span> <span class="o">=</span> <span class="n">outRange</span> <span class="k">if</span> <span class="n">_outRange</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">_outRange</span>
    <span class="n">outBorders</span><span class="p">,</span> <span class="n">outPscale</span> <span class="o">=</span> <span class="n">_pixel_borders</span><span class="p">(</span><span class="n">outRange</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="n">newLog</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="n">base</span><span class="p">)</span>
    <span class="n">outX</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">outBorders</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">*</span><span class="n">outBorders</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="k">if</span> <span class="n">newLog</span> \
            <span class="k">else</span> <span class="p">(</span><span class="n">outBorders</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">+</span><span class="n">outBorders</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="mf">2.0</span>

    <span class="c1">#If the input is logarithmically binned, work in log space</span>
    <span class="k">if</span> <span class="n">inLog</span><span class="p">:</span>
        <span class="n">inBorders</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">inBorders</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>
        <span class="n">outBorders</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">outBorders</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>
    <span class="c1"># Convert the borders to the input pixel units</span>
    <span class="n">outBorders</span> <span class="o">/=</span> <span class="n">inPscale</span>
    <span class="n">inBorders</span> <span class="o">/=</span> <span class="n">inPscale</span>

    <span class="c1"># Perform the integration</span>
    <span class="k">if</span> <span class="n">flat</span><span class="p">:</span>
        <span class="c1"># Get the new spectrum by performing an analytic integral</span>
        <span class="c1"># assuming the value is flat across each pixel</span>
        <span class="c1">#   - From M. Cappellari</span>
        <span class="n">k</span> <span class="o">=</span> <span class="p">(</span><span class="n">outBorders</span> <span class="o">-</span> <span class="n">inBorders</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">outY</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">reduceat</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">k</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">outY</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="n">outY</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">((</span><span class="n">outBorders</span> <span class="o">-</span> <span class="n">inBorders</span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="o">*</span><span class="n">y</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Get the new spectrum by performing an analytic integral</span>
        <span class="c1"># assuming a basic linear interpolation between the pixel values</span>
        <span class="c1">#   - Not as elegant as Michele&#39;s code above, but it gets the</span>
        <span class="c1">#     job done</span>

        <span class="c1"># Create a sorted list of the pixel centers and the output</span>
        <span class="c1"># borders</span>
        <span class="n">inCenters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">inBorders</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">*</span><span class="n">inBorders</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="k">if</span> <span class="n">newLog</span> \
                         <span class="k">else</span> <span class="p">(</span><span class="n">inBorders</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">+</span><span class="n">inBorders</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="mf">2.0</span>
        <span class="n">_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">outBorders</span><span class="p">,</span> <span class="n">inCenters</span> <span class="p">)</span>
        <span class="n">srt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">_x</span><span class="p">)</span>
        <span class="n">_x</span> <span class="o">=</span> <span class="n">_x</span><span class="p">[</span><span class="n">srt</span><span class="p">]</span>

        <span class="c1"># Linearly interpolate the input function at the output border positions</span>
        <span class="n">_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">y</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="n">outBorders</span><span class="o">-</span><span class="n">inCenters</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="p">(</span><span class="n">d</span><span class="o">-</span><span class="n">k</span><span class="p">))</span><span class="o">*</span><span class="n">y</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">d</span><span class="o">-</span><span class="n">k</span><span class="p">)</span><span class="o">*</span><span class="n">_y</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">y</span><span class="p">)[</span><span class="n">srt</span><span class="p">]</span>

        <span class="c1"># Flag the input pixel centers for removal from reduceat</span>
        <span class="n">flg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">_x</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">flg</span><span class="p">[</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">_f</span> <span class="o">=</span> <span class="n">flg</span><span class="p">[</span><span class="n">srt</span><span class="p">]</span>

        <span class="c1"># Compute the integrand</span>
        <span class="k">if</span> <span class="n">inLog</span><span class="p">:</span>
            <span class="n">_y</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">_x</span><span class="o">*</span><span class="n">inPscale</span><span class="p">)</span>
        <span class="n">integ</span> <span class="o">=</span> <span class="p">(</span><span class="n">_y</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">+</span><span class="n">_y</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">_x</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span>

        <span class="c1"># Use reduceat to calculate the integral</span>
        <span class="n">indx</span> <span class="o">=</span> <span class="n">_f</span> <span class="o">&lt;</span> <span class="mi">1</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">_y</span><span class="o">.</span><span class="n">size</span><span class="p">)[</span><span class="n">indx</span><span class="p">]</span>
        <span class="n">outY</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">reduceat</span><span class="p">(</span><span class="n">integ</span><span class="p">,</span> <span class="n">k</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="k">if</span> <span class="n">k</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">_y</span><span class="o">.</span><span class="n">size</span><span class="o">-</span><span class="mi">1</span> \
                    <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">reduceat</span><span class="p">(</span><span class="n">integ</span><span class="p">,</span> <span class="n">k</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># Do not conserve the integral over the size of the pixel</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">conserve</span><span class="p">:</span>
        <span class="n">outY</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">outBorders</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">inLog</span><span class="p">:</span>
        <span class="n">outY</span> <span class="o">/=</span> <span class="n">outX</span>

    <span class="c1"># Set values for extrapolated regions</span>
    <span class="k">if</span> <span class="n">outRange</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="p">(</span><span class="n">outRange</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">inRange</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">or</span> <span class="n">outRange</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">inRange</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">outY</span><span class="p">[</span> <span class="p">(</span><span class="n">outX</span> <span class="o">&lt;</span> <span class="n">inRange</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">|</span> <span class="p">(</span><span class="n">outX</span> <span class="o">&gt;</span> <span class="n">inRange</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="p">]</span> <span class="o">=</span> <span class="n">ext_value</span>

    <span class="c1"># Return new coordinates and rebinned values</span>
    <span class="k">return</span> <span class="n">outX</span><span class="p">,</span> <span class="n">outY</span></div>

<div class="viewcode-block" id="downgrade"><a class="viewcode-back" href="../firefly_instrument.html#firefly_instrument.downgrade">[docs]</a><span class="k">def</span> <span class="nf">downgrade</span><span class="p">(</span><span class="n">wave</span><span class="p">,</span> <span class="n">flux</span><span class="p">,</span> <span class="n">deltal_in</span><span class="p">,</span> <span class="n">sigma_galaxy</span><span class="p">,</span> <span class="n">wave_instrument</span><span class="p">,</span> <span class="n">r_instrument</span><span class="p">):</span>

	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Adapted from the manga DAP downgrader from Kyle Westfall.</span>

<span class="sd">	Downgrades an input spectrum to a given galaxy velocity dispersion</span>
<span class="sd">	using the input SEDs resolution and the resolution of the observation.</span>

<span class="sd">	Returns flux of downgraded SED.</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="n">sig2fwhm</span>        <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">2.0</span><span class="p">))</span>
	<span class="n">fwhm</span>    <span class="o">=</span> <span class="n">deltal_in</span><span class="o">/</span><span class="n">wave</span><span class="o">*</span><span class="n">c</span>
	<span class="n">sigma</span>   <span class="o">=</span> <span class="n">fwhm</span><span class="o">/</span><span class="n">sig2fwhm</span>
	<span class="n">sres</span>    <span class="o">=</span> <span class="n">wave</span><span class="o">/</span><span class="n">deltal_in</span>

	<span class="n">new_sig</span>     <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">wave</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
	<span class="c1"># match wavelength between model and instrument to downgrade</span>
	<span class="k">def</span> <span class="nf">find_nearest</span><span class="p">(</span><span class="n">array</span><span class="p">,</span><span class="n">value</span><span class="p">):</span>
		<span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">array</span><span class="o">-</span><span class="n">value</span><span class="p">))</span><span class="o">.</span><span class="n">argmin</span><span class="p">()</span>
		<span class="k">return</span> <span class="n">idx</span><span class="p">,</span><span class="n">array</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

	<span class="k">for</span> <span class="n">wi</span><span class="p">,</span><span class="n">w</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">wave</span><span class="p">):</span>
		<span class="n">index</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="n">find_nearest</span><span class="p">(</span><span class="n">wave_instrument</span><span class="p">,</span><span class="n">w</span><span class="p">)</span>
		<span class="n">sig_instrument</span> <span class="o">=</span> <span class="n">c</span><span class="o">/</span><span class="n">r_instrument</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">/</span><span class="n">sig2fwhm</span>
		<span class="n">new_sig</span><span class="p">[</span><span class="n">wi</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">sigma_galaxy</span><span class="o">**</span><span class="mf">2.0</span> <span class="o">+</span><span class="n">sig_instrument</span><span class="o">**</span><span class="mf">2.0</span><span class="p">)</span>

	<span class="n">new_fwhm</span>    <span class="o">=</span> <span class="n">sig2fwhm</span> <span class="o">*</span> <span class="n">new_sig</span>
	<span class="n">new_sres</span>    <span class="o">=</span> <span class="n">c</span> <span class="o">/</span> <span class="n">new_fwhm</span>

	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">wave</span><span class="p">)</span><span class="o">&lt;</span><span class="mi">5</span><span class="p">:</span>
		<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Not enough wavelength points...!&quot;</span><span class="p">)</span>

	<span class="n">a_wave</span> <span class="o">=</span> <span class="n">wave</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">wave</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
	<span class="n">b_wave</span> <span class="o">=</span> <span class="n">wave</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">-</span><span class="n">wave</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

	<span class="k">if</span> <span class="n">b_wave</span><span class="o">-</span><span class="n">a_wave</span> <span class="o">&lt;</span> <span class="mf">0.000001</span><span class="o">*</span><span class="n">a_wave</span><span class="p">:</span>
		<span class="n">log_wave</span> <span class="o">=</span> <span class="kc">False</span>
	<span class="k">else</span><span class="p">:</span>
		<span class="n">log_wave</span> <span class="o">=</span> <span class="kc">True</span>

	<span class="n">new_flux</span><span class="p">,</span> <span class="n">matched_sres</span><span class="p">,</span> <span class="n">sigma_offset</span><span class="p">,</span> <span class="n">new_mask</span> <span class="o">=</span> <span class="n">match_spectral_resolution</span><span class="p">(</span><span class="n">wave</span><span class="p">,</span> <span class="n">flux</span><span class="p">,</span> <span class="n">sres</span><span class="p">,</span> <span class="n">wave</span><span class="p">,</span> <span class="n">new_sres</span><span class="p">,</span> <span class="n">min_sig_pix</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">log10</span><span class="o">=</span><span class="n">log_wave</span><span class="p">,</span> <span class="n">new_log10</span><span class="o">=</span><span class="n">log_wave</span><span class="p">)</span>

	<span class="k">return</span> <span class="n">new_flux</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">FIREFLY - Fitting Iteratively for Relative Likelihood Analysis 1.0.4 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2017, Johan Comparat.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.5.3.
    </div>
  </body>
</html>